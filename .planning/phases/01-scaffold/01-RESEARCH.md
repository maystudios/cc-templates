# Phase 1: Scaffold - Research

**Researched:** 2026-02-24
**Domain:** Node.js CLI npm package scaffolding â€” bin entry point, package.json shape, ES Modules, YAML frontmatter build script
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**CLI help output:**
- Rich `--help`: branded header line ("cc-templates â€” Install Claude Code components"), then Usage, then all 4 flags (--skill, --hook, --command, --mcp, --list, --help), then Examples section
- All four component type flags listed even though install logic ships in Phase 2 â€” sets expectations early
- Examples use `npx cc-templates` invocation (no alias)

**Package file shape:**
- Components nested by type in repo: `components/skills/`, `components/hooks/`, `components/commands/`, `components/mcp/`
- npm package ships only CLI code: `bin/`, `src/`, `package.json`, `README`, `components.json` â€” component files stay in GitHub, fetched at runtime
- Single `bin/index.js` entry point (thin shim that imports from `src/`)
- ES Modules (`"type": "module"` in package.json, import/export syntax)

**components.json schema:**
- Grouped by type at top level: `{ skills: [...], hooks: [...], commands: [...], mcp: [...] }`
- Fields per entry: `name`, `description`, `author`, `version`, `tags` (array)
- Auto-generated by a build script that scans component dirs and reads frontmatter â€” committed to repo root
- Installer fetches it from GitHub raw URL as the catalog source

**Component frontmatter:**
- Frontmatter lives in the main component file (skill.md, hook config, etc.), not a separate metadata file
- Required fields: `name`, `description` â€” build fails with clear error if missing
- Optional fields: `author`, `version`, `tags`, `requires`
- `requires` supports `env` and `tools` sub-keys: `requires: { env: [GEMINI_API_KEY], tools: [ffmpeg] }`
- Catalog build script exits non-zero on missing required fields and prints which file + which field

### Claude's Discretion
- Exact progress/error message wording
- Whether to use a YAML parsing library or regex for frontmatter extraction
- npm `files` field configuration details
- `bin` field name in package.json (e.g., `cc-templates` vs `cct`)

### Deferred Ideas (OUT OF SCOPE)
- None â€” discussion stayed within phase scope
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| COMP-04 | All component files include YAML frontmatter with `name`, `description`, and optional `author` fields | YAML frontmatter standard: use js-yaml 4.x to parse; build script walks component dirs, extracts frontmatter, fails fast on missing required fields |
| COMP-05 | Pre-generated `components.json` catalog is shipped inside the npm package for instant offline listing | Build script pattern verified against reference implementation (claude-code-templates v1.28.16); ship via npm `files` field; grouped by type schema documented |
</phase_requirements>

---

## Summary

Phase 1 establishes the npm package skeleton: the `package.json` is configured correctly for an ESM CLI, the `bin/index.js` entry point is wired so `npx cc-templates --help` works, the component directory tree is seeded with frontmatter-annotated component files, and a build script generates `components.json` from those files. No install logic is written â€” this is purely packaging and catalog shape.

The reference implementation (`claude-code-templates` v1.28.16, analyzed February 2026) uses `commander` for argument parsing and a Python script for catalog generation. For this project the decisions are locked to ESM (`"type": "module"`) and JavaScript-only, so the catalog build script will be a Node.js script using `js-yaml` to parse frontmatter. Commander 14 is the correct choice â€” it requires Node 20+ and supports ESM imports natively via `import { Command } from 'commander'`.

One important conflict exists between pre-phase notes in STATE.md ("Use CommonJS; pin chalk@4.1.2") and the locked CONTEXT.md decision ("ES Modules, `"type": "module"`"). **CONTEXT.md takes precedence.** The ESM decision means: use chalk 5.x (ESM-only) rather than chalk 4.1.2 (CJS), and use `import` syntax throughout. Commander 14 works fine with ESM. js-yaml 4.1.1 is a CJS package but Node.js ESM can `import` CJS packages as default imports â€” this works cleanly.

**Primary recommendation:** Scaffold as ESM-first with commander 14 + js-yaml 4.1.1 + chalk 5.x. The `bin/index.js` shim uses `#!/usr/bin/env node` shebang and `import` syntax. The catalog build script is a separate `scripts/build-catalog.js` that walks `components/` and writes `components.json`.

---

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| commander | ^14.0.0 | Argument parsing, `--help` output, `--version` | Industry standard for Node CLIs; generates well-formatted help automatically; requires Node 20+; ESM-compatible via named import |
| js-yaml | ^4.1.1 | Parse YAML frontmatter in component files | Battle-tested; CJS but importable from ESM as default import; 4.x drops YAML 1.1 quirks; widely used by Vite, 11ty, etc. |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| chalk | ^5.4.1 | Terminal color in --help output and error messages | ESM-only; use in Phase 1 for branded header line in help; chalk 5 is ESM-native |
| node:fs/promises | built-in | Reading component files in build script | Use native fs instead of third-party for the catalog builder |
| node:path | built-in | Cross-platform path manipulation | Use instead of string concatenation |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| commander | yargs | yargs is heavier and more config-driven; commander is simpler for a four-flag CLI |
| js-yaml | gray-matter | gray-matter has a known ESM interop issue (TypeError: matter is not a function with `import`); js-yaml does not have this problem when imported as default |
| js-yaml | regex for frontmatter | Regex is fragile on multi-line values and edge cases in YAML; js-yaml handles all valid YAML 1.2 syntax |
| chalk 5 | chalk 4.1.2 | chalk 4.1.2 is CJS and would fight the `"type": "module"` setup; chalk 5.x is ESM-native â€” use 5.x |
| Node.js build script | Python script | Reference implementation uses Python; locked decision is JS-only â€” stick with `node scripts/build-catalog.js` |

**Installation:**

```bash
npm install commander@^14 js-yaml@^4 chalk@^5
```

---

## Architecture Patterns

### Recommended Project Structure

```
cc-templates/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ index.js          # Shebang + thin shim: imports src/cli.js and calls run()
â”œâ”€â”€ src/
â”‚   â””â”€â”€ cli.js            # commander Program setup, --help definition, option routing stubs
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ skills/           # Each skill: a directory with skill.md (has frontmatter)
â”‚   â”œâ”€â”€ hooks/            # Each hook: a .json file (with frontmatter comment or separate .md)
â”‚   â”œâ”€â”€ commands/         # Each command: a .md file with YAML frontmatter
â”‚   â””â”€â”€ mcp/              # Each mcp entry (future)
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ build-catalog.js  # Reads components/, extracts frontmatter, writes components.json
â”œâ”€â”€ components.json        # Generated artifact, committed to repo root, shipped in npm package
â”œâ”€â”€ package.json           # "type": "module", "bin", "files", "scripts.build"
â””â”€â”€ README.md
```

### Pattern 1: ESM bin shim

**What:** A thin `bin/index.js` that only shebangs + imports, delegates all logic to `src/`
**When to use:** Always â€” keeps bin file minimal, allows `src/cli.js` to be tested independently

```javascript
// bin/index.js
#!/usr/bin/env node
// Source: https://docs.npmjs.com/cli/v11/configuring-npm/package-json/#bin
// and https://2ality.com/2022/07/nodejs-esm-shell-scripts.html

import { run } from '../src/cli.js';

run();
```

```javascript
// src/cli.js
// Source: https://github.com/tj/commander.js (v14 ESM import pattern)

import { Command } from 'commander';
import { createRequire } from 'node:module';
import { fileURLToPath } from 'node:url';
import { readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';

const __dirname = dirname(fileURLToPath(import.meta.url));
const pkg = JSON.parse(readFileSync(join(__dirname, '../package.json'), 'utf8'));

export function run() {
  const program = new Command();

  program
    .name('cc-templates')
    .description('cc-templates â€” Install Claude Code components')
    .version(pkg.version)
    .helpOption('-h, --help', 'Show this help message');

  program
    .option('--skill <name>',   'Install a skill component')
    .option('--hook <name>',    'Install a hook component')
    .option('--command <name>', 'Install a command component')
    .option('--mcp <name>',     'Install an MCP component')
    .option('--list',           'List all available components');

  program.addHelpText('beforeAll', 'cc-templates â€” Install Claude Code components\n');

  program.addHelpText('after', `
Examples:
  npx cc-templates --skill video-download
  npx cc-templates --hook auto-format
  npx cc-templates --list`);

  program.parse(process.argv);
}
```

### Pattern 2: package.json shape for ESM CLI with restricted publish set

**What:** The `files`, `bin`, `type`, and `exports` fields must be set correctly for an ESM CLI that publishes a subset of repo files.

```json
{
  "name": "cc-templates",
  "version": "0.1.0",
  "type": "module",
  "bin": {
    "cc-templates": "./bin/index.js"
  },
  "files": [
    "bin/",
    "src/",
    "components.json",
    "README.md"
  ],
  "scripts": {
    "build": "node scripts/build-catalog.js",
    "prepublishOnly": "npm run build"
  },
  "engines": {
    "node": ">=20"
  }
}
```

Note: `package.json` and `README.md` are always included by npm regardless of the `files` field. Listing them explicitly is harmless and makes intent clear.

### Pattern 3: catalog build script

**What:** A Node.js script that walks `components/`, reads each component's main file, extracts YAML frontmatter, validates required fields, and writes `components.json`.

```javascript
// scripts/build-catalog.js
// Uses js-yaml 4.x imported as default (CJS-from-ESM pattern)

import { readFileSync, writeFileSync, readdirSync, statSync } from 'node:fs';
import { join, extname } from 'node:path';
import { fileURLToPath } from 'node:url';
import yaml from 'js-yaml';   // CJS default import works in ESM context

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const ROOT = join(__dirname, '..');
const COMPONENT_TYPES = ['skills', 'hooks', 'commands', 'mcp'];
const REQUIRED_FIELDS = ['name', 'description'];

function extractFrontmatter(filePath) {
  const content = readFileSync(filePath, 'utf8');
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return null;
  return yaml.load(match[1]);
}

function buildCatalog() {
  const catalog = {};
  const errors = [];

  for (const type of COMPONENT_TYPES) {
    catalog[type] = [];
    const typeDir = join(ROOT, 'components', type);
    // walk entries (flat or one level of subdirectories)
    for (const entry of readdirSync(typeDir)) {
      const entryPath = join(typeDir, entry);
      const mainFile = statSync(entryPath).isDirectory()
        ? join(entryPath, 'skill.md')   // skills are directories
        : entryPath;                    // others are single files

      const fm = extractFrontmatter(mainFile);
      if (!fm) {
        errors.push(`${mainFile}: missing frontmatter`);
        continue;
      }

      for (const field of REQUIRED_FIELDS) {
        if (!fm[field]) errors.push(`${mainFile}: missing required field "${field}"`);
      }

      catalog[type].push({
        name: fm.name,
        description: fm.description,
        author: fm.author ?? null,
        version: fm.version ?? null,
        tags: fm.tags ?? [],
      });
    }
  }

  if (errors.length) {
    for (const e of errors) console.error(`ERROR: ${e}`);
    process.exit(1);
  }

  writeFileSync(join(ROOT, 'components.json'), JSON.stringify(catalog, null, 2));
  console.log('components.json written successfully.');
}

buildCatalog();
```

### Anti-Patterns to Avoid

- **Putting logic in `bin/index.js`:** The shim must stay thin â€” one import, one function call. Logic in bin prevents unit testing.
- **Using `require()` anywhere:** The project is `"type": "module"` â€” any `require()` call will throw. Use `import` and `createRequire` only when truly necessary.
- **Omitting `"type": "module"` from package.json:** Without it, `.js` files are interpreted as CJS and `import` statements fail.
- **Forgetting `#!/usr/bin/env node` on bin/index.js:** The shebang is required for `npx` to execute the file. Without it, npm will add the shebang at publish time â€” but it is safer and more explicit to include it in source.
- **Not setting `"engines": { "node": ">=20" }`:** commander 14 requires Node 20. Declaring this makes `npm install` warn users on old Node versions.
- **Using gray-matter for frontmatter parsing in an ESM project:** gray-matter 4.0.3 has a known ESM interop issue where `import matter from 'gray-matter'` produces a non-function. Use js-yaml + manual delimiter extraction instead.
- **Hardcoding version in src/cli.js:** Read version from package.json at runtime with `JSON.parse(readFileSync(...))`. This keeps a single source of truth.
- **Publishing `components/` directory inside the npm package:** Component source files must NOT ship with the package (they stay in GitHub, fetched at runtime). Verify with `npm pack --dry-run` before any publish.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Argument parsing and --help generation | Custom argv parser | commander 14 | help formatting, error messages, -h shorthand, version flag are all complex to get right consistently |
| YAML parsing | Regex-based frontmatter extractor | js-yaml | Edge cases: multi-line strings, quoted colons, arrays, nested objects â€” regex fails on all of them |
| File inclusion control at publish time | .npmignore rules | `"files"` field in package.json | `files` field is explicit and checked into source; .npmignore is easy to forget to update |

**Key insight:** The only hand-rolling justified in Phase 1 is the frontmatter-to-JSON catalog builder â€” that logic is specific to the project's schema, but it should use `js-yaml` for the YAML parsing step itself.

---

## Common Pitfalls

### Pitfall 1: ESM + CJS interop with js-yaml

**What goes wrong:** `import yaml from 'js-yaml'` in an `"type": "module"` project may fail with "The requested module 'js-yaml' does not provide an export named 'default'" on some Node versions.
**Why it happens:** js-yaml 4.x is CJS; Node.js ESM treats CJS packages as having a synthetic default export (the `module.exports` object). This generally works but can be confused by bundlers or certain Node edge cases.
**How to avoid:** Use `import yaml from 'js-yaml'` (default import). If this fails, use `createRequire`: `const require = createRequire(import.meta.url); const yaml = require('js-yaml')`. Test this explicitly in the target Node version.
**Warning signs:** `ERR_PACKAGE_IMPORT_NOT_DEFINED` or "does not provide a named export" in error output.

### Pitfall 2: Missing shebang on bin entry point

**What goes wrong:** `npx cc-templates` fails with "permission denied" or executes but Node throws a syntax error on line 1.
**Why it happens:** npm adds the shebang only in certain packaging flows; if the shebang is missing and the file starts with `import`, the OS shell tries to interpret it as a shell script.
**How to avoid:** Always include `#!/usr/bin/env node` as the very first line of `bin/index.js`, before any blank lines or comments.
**Warning signs:** `npx cc-templates` silently fails or gives a cryptic shell error instead of a Node error.

### Pitfall 3: Publishing component source files in the npm tarball

**What goes wrong:** `npm pack` bundles the entire `components/` directory, bloating the package and shipping content that should only exist on GitHub.
**Why it happens:** If `"files"` field is not set, npm defaults to `["*"]` (include everything).
**How to avoid:** Set `"files": ["bin/", "src/", "components.json", "README.md"]` in package.json. Validate with `npm pack --dry-run` and confirm `components/` does NOT appear in the output.
**Warning signs:** `npm pack --dry-run` output lists files under `components/skills/`, `components/hooks/`, etc.

### Pitfall 4: chalk 5 vs chalk 4 mismatch

**What goes wrong:** Attempting to `require('chalk')` or using chalk 4.1.2 in an ESM project throws `ERR_REQUIRE_ESM`.
**Why it happens:** chalk 5.x is ESM-only; chalk 4.x is CJS-only. The locked decision for ESM means chalk 4.x must NOT be used.
**How to avoid:** Install `chalk@^5` and use `import chalk from 'chalk'`. Never mix chalk 4 with `"type": "module"`.
**Warning signs:** `ERR_REQUIRE_ESM` at startup, or chalk not applying colors.

### Pitfall 5: `npm pack --dry-run` success criteria

**What goes wrong:** A developer runs `npm pack --dry-run` but doesn't audit the output â€” stray files (tests, scripts, components/) get published unnoticed.
**Why it happens:** Humans read the first few lines and assume the rest is correct.
**How to avoid:** After `npm pack --dry-run`, programmatically (or carefully manually) confirm that EVERY listed file is one of: `bin/index.js`, `src/*.js`, `components.json`, `package.json`, `README.md`. The success criterion for this phase requires exactly this.
**Warning signs:** Any path in `npm pack --dry-run` output that starts with `components/`, `scripts/`, or `.planning/`.

### Pitfall 6: Commander 14 requires Node 20

**What goes wrong:** Install or runtime fails on Node 18 or older.
**Why it happens:** commander 14 explicitly requires `engines.node >= 20`.
**How to avoid:** Declare `"engines": { "node": ">=20" }` in package.json. The project's README should state the Node requirement.
**Warning signs:** `npm install` warning about engine mismatch; runtime import errors on older Node.

---

## Code Examples

Verified patterns from official sources and the reference implementation:

### package.json minimum viable shape (ESM CLI)

```json
{
  "name": "cc-templates",
  "version": "0.1.0",
  "description": "Install Claude Code components with one command",
  "type": "module",
  "bin": {
    "cc-templates": "./bin/index.js"
  },
  "files": [
    "bin/",
    "src/",
    "components.json",
    "README.md"
  ],
  "scripts": {
    "build": "node scripts/build-catalog.js",
    "prepublishOnly": "npm run build"
  },
  "engines": {
    "node": ">=20"
  },
  "dependencies": {
    "chalk": "^5.4.1",
    "commander": "^14.0.0",
    "js-yaml": "^4.1.1"
  }
}
```
Source: npm docs (files field), tj/commander.js README (bin pattern), chalk/chalk README (version 5 = ESM-only)

### Commander 14 ESM help setup

```javascript
// Source: https://github.com/tj/commander.js â€” ESM import pattern (commander/esm.mjs or direct import)
import { Command } from 'commander';

const program = new Command();

program
  .name('cc-templates')
  .version('0.1.0')
  .helpOption('-h, --help', 'Show this help message');

// addHelpText positions: 'before', 'after', 'beforeAll', 'afterAll'
program.addHelpText('beforeAll', 'cc-templates â€” Install Claude Code components\n');

program
  .option('--skill <name>',   'Install a skill component')
  .option('--hook <name>',    'Install a hook component')
  .option('--command <name>', 'Install a command component')
  .option('--mcp <name>',     'Install an MCP component')
  .option('--list',           'List all available components');

program.addHelpText('after', `
Examples:
  npx cc-templates --list
  npx cc-templates --skill video-download
  npx cc-templates --hook auto-format
  npx cc-templates --command git-summary`);
```

### component frontmatter example (skill.md)

```markdown
---
name: video-download
description: Download videos from YouTube, Instagram, TikTok, and more via yt-dlp
author: cc-templates
version: 1.0.0
tags:
  - video
  - download
  - media
requires:
  tools:
    - yt-dlp
---

# video-download skill

...skill content here...
```

### js-yaml import in ESM context

```javascript
// Source: js-yaml 4.1.1 npm page; CJS package importable as ESM default
import yaml from 'js-yaml';

// If default import fails, use createRequire fallback:
// import { createRequire } from 'node:module';
// const require = createRequire(import.meta.url);
// const yaml = require('js-yaml');

const frontmatter = yaml.load(`
name: video-download
description: Download videos
tags: [video, download]
`);
// => { name: 'video-download', description: 'Download videos', tags: ['video', 'download'] }
```

### npm pack --dry-run expected output (what success looks like)

```
npm notice ðŸ“¦  [email protected]
npm notice === Tarball Contents ===
npm notice  XXX B  bin/index.js
npm notice  XXX B  src/cli.js
npm notice  XXX B  components.json
npm notice  XXX B  package.json
npm notice  XXX B  README.md
npm notice === Tarball Details ===
```
No `components/` paths should appear. Any appearance of `components/skills/` or `components/hooks/` is a failure.

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| chalk 4.x (CJS) | chalk 5.x (ESM-only) | chalk 5.0 released 2022 | ESM projects must use chalk 5; CJS projects must stay on chalk 4 |
| `require('commander')` | `import { Command } from 'commander'` | commander 12+ improved ESM support; v14 requires Node 20 | Named ESM import is the standard pattern |
| Python script for catalog generation | Node.js script for catalog generation | Project-level decision | Simpler toolchain; no Python dependency required |
| `module.exports` / CJS | `"type": "module"` + `export` | Node 12+ ESM stable, Node 20 ESM mature | All .js files interpreted as ESM; no dual-format complexity needed for a CLI tool |

**Deprecated/outdated:**
- chalk 4.1.2 in an ESM project: incompatible; replaced by chalk 5.x
- gray-matter for frontmatter in ESM: has known `import` interop issues; js-yaml + manual `---` delimiter extraction is more reliable

---

## Open Questions

1. **ESM import of js-yaml 4.x: default import reliability**
   - What we know: js-yaml 4.x is CJS; Node ESM can import CJS as synthetic default
   - What's unclear: Whether this works uniformly across Node 20, 22, and 23
   - Recommendation: Implement as `import yaml from 'js-yaml'` and add the `createRequire` fallback pattern in a comment. Test on Node 20 (minimum) before declaring done.

2. **`bin` field name: `cc-templates` vs `cct`**
   - What we know: This is marked "Claude's Discretion" in CONTEXT.md
   - What's unclear: Whether a short alias should be provided alongside the full name
   - Recommendation: Use `cc-templates` as the primary name only. The reference implementation registers both `claude-code-templates` and `cct` as aliases, but the locked decision says "Examples use `npx cc-templates` invocation (no alias)" â€” a single entry in `bin` is correct.

3. **npm name availability for `cc-templates`**
   - What we know: STATE.md flags "Verify `cc-templates` npm name is still available and register it as first action of Phase 1"
   - What's unclear: Whether it is still unclaimed as of today (2026-02-24)
   - Recommendation: The very first task in Phase 1 must be `npm view cc-templates` to check. If taken, the planner must pause for a user decision on an alternative name.

---

## Sources

### Primary (HIGH confidence)
- Reference implementation `claude-code-templates-architecture.md` at repo root â€” full engineering breakdown of the comparable tool at v1.28.16; package structure, bin/src separation, frontmatter format, components.json schema all verified against this document
- https://github.com/tj/commander.js â€” ESM import pattern (`import { Command } from 'commander'`), Node 20 requirement, `addHelpText` API
- https://docs.npmjs.com/cli/v11/configuring-npm/package-json/ â€” `files` field semantics, `bin` field rules, always-included files (package.json, README.md, LICENSE)

### Secondary (MEDIUM confidence)
- https://www.npmjs.com/package/js-yaml â€” version 4.1.1 confirmed current; CJS package, importable from ESM as default
- https://github.com/chalk/chalk â€” chalk 5 is ESM-only; chalk 4.1.2 is last CJS version (verified against multiple sources)
- https://github.com/jonschlinkert/gray-matter/issues/171 â€” gray-matter ESM interop bug confirmed; justifies using js-yaml instead
- https://stevefenton.co.uk/blog/2024/01/testing-npm-publish/ â€” `npm pack --dry-run` output format and usage

### Tertiary (LOW confidence)
- WebSearch results on commander 14 Node 20 requirement â€” stated in multiple search summaries but not directly verified against package.json of commander@14

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH â€” commander, js-yaml, chalk all verified via web sources; versions confirmed
- Architecture: HIGH â€” patterns derived directly from reference implementation architecture doc at repo root
- Pitfalls: MEDIUM â€” ESM/CJS interop pitfalls verified against GitHub issues and authoritative blog posts; chalk 4 vs 5 is well-documented

**Research date:** 2026-02-24
**Valid until:** 2026-03-24 (commander and chalk are stable; js-yaml 4.x is in maintenance mode â€” low churn risk)
