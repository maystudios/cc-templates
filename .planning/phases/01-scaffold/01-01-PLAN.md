---
phase: 01-scaffold
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bin/index.js
  - src/cli.js
  - scripts/build-catalog.js
  - components/skills/video-download/skill.md
  - components/skills/video-fetch-and-summarize/skill.md
  - components/skills/video-summarizer/skill.md
  - components/hooks/.gitkeep
  - components/commands/.gitkeep
  - components/mcp/.gitkeep
  - components.json
  - README.md
  - .gitignore
autonomous: true
requirements:
  - COMP-04
  - COMP-05

must_haves:
  truths:
    - "`npx cc-templates --help` prints branded header 'cc-templates — Install Claude Code components', Usage block, all flags (--skill, --hook, --command, --mcp, --list, --help), and Examples section — exits 0"
    - "`npm pack --dry-run` lists ONLY bin/index.js, src/cli.js, components.json, package.json, README.md — no components/ paths appear"
    - "`components.json` exists at repo root with top-level keys: skills, hooks, commands, mcp — skills array contains 3 entries (video-download, video-fetch-and-summarize, video-summarizer)"
    - "All three skill.md files contain valid YAML frontmatter with `name` and `description` fields; `npm run build` exits 0"
    - "`node --input-type=module < bin/index.js` (or direct invocation) does not error on import resolution"
  artifacts:
    - path: "package.json"
      provides: "ESM CLI package shape"
      contains: '"type": "module"'
    - path: "bin/index.js"
      provides: "CLI entry point shim"
      contains: "#!/usr/bin/env node"
    - path: "src/cli.js"
      provides: "commander program definition"
      exports: ["run"]
    - path: "scripts/build-catalog.js"
      provides: "Catalog generation script"
      contains: "buildCatalog"
    - path: "components.json"
      provides: "Pre-generated component catalog"
      contains: '"skills"'
    - path: "components/skills/video-download/skill.md"
      provides: "Seed skill component"
      contains: "name: video-download"
  key_links:
    - from: "bin/index.js"
      to: "src/cli.js"
      via: "ESM import"
      pattern: "import.*run.*from.*src/cli.js"
    - from: "src/cli.js"
      to: "package.json"
      via: "readFileSync for version"
      pattern: "readFileSync.*package\\.json"
    - from: "scripts/build-catalog.js"
      to: "components/skills/*/skill.md"
      via: "readdirSync + frontmatter extraction"
      pattern: "readdirSync.*components"
    - from: "scripts/build-catalog.js"
      to: "components.json"
      via: "writeFileSync"
      pattern: "writeFileSync.*components\\.json"
---

<objective>
Establish the complete npm package scaffold for cc-templates: secure npm name, create correct ESM package shape with a working CLI entry point, seed the component library with the three skill components (YAML frontmatter), write the catalog build script, and generate components.json.

Purpose: Phase 2 (Core Installer) cannot begin until the package name is confirmed, the bin entry point works, and the component catalog exists. This is the foundation every subsequent phase builds on.

Output: A runnable npm CLI package where `npx cc-templates --help` works, `npm pack --dry-run` shows only the intended files, and `components.json` is pre-generated and committed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-scaffold/01-CONTEXT.md
@.planning/phases/01-scaffold/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: npm name check, package scaffold, and working CLI entry point</name>
  <files>
    package.json
    bin/index.js
    src/cli.js
    README.md
    .gitignore
  </files>
  <action>
**Step 1: Verify npm name availability**

Run `npm view cc-templates` (or `npm view cc-templates --json`). If the command returns package info (name is taken), STOP and output a message explaining the name is taken and listing the returned owner/version. Do NOT proceed with package setup until this is resolved. If the command returns `npm error 404` or similar "not found" error, the name is available — proceed.

**Step 2: Initialize package.json**

Create `package.json` at the repo root with this exact shape (do not add any field not listed here):

```json
{
  "name": "cc-templates",
  "version": "0.1.0",
  "description": "Install Claude Code components with one command",
  "type": "module",
  "bin": {
    "cc-templates": "./bin/index.js"
  },
  "files": [
    "bin/",
    "src/",
    "components.json",
    "README.md"
  ],
  "scripts": {
    "build": "node scripts/build-catalog.js",
    "prepublishOnly": "npm run build"
  },
  "engines": {
    "node": ">=20"
  },
  "dependencies": {
    "chalk": "^5.4.1",
    "commander": "^14.0.0",
    "js-yaml": "^4.1.1"
  },
  "keywords": ["claude", "claude-code", "components", "cli"],
  "license": "MIT"
}
```

Run `npm install` to generate package-lock.json and node_modules.

**Step 3: Create bin/index.js**

Create `bin/index.js` — this MUST be the very first line (no blank lines before shebang):

```javascript
#!/usr/bin/env node
import { run } from '../src/cli.js';

run();
```

After writing the file, make it executable: `chmod +x bin/index.js` (on Windows this is a no-op but do not skip).

**Step 4: Create src/cli.js**

Create `src/cli.js` with the commander program. Use `readFileSync` to read version from package.json (single source of truth, never hardcode version):

```javascript
import { Command } from 'commander';
import { readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const pkg = JSON.parse(readFileSync(join(__dirname, '../package.json'), 'utf8'));

export function run() {
  const program = new Command();

  program
    .name('cc-templates')
    .description('Install Claude Code components with one command')
    .version(pkg.version, '-v, --version', 'Show version number')
    .helpOption('-h, --help', 'Show this help message');

  program.addHelpText('beforeAll', 'cc-templates — Install Claude Code components\n');

  program
    .option('--skill <name>',   'Install a skill component')
    .option('--hook <name>',    'Install a hook component')
    .option('--command <name>', 'Install a command component')
    .option('--mcp <name>',     'Install an MCP component')
    .option('--list',           'List all available components');

  program.addHelpText('after', `
Examples:
  npx cc-templates --list
  npx cc-templates --skill video-download
  npx cc-templates --hook auto-format
  npx cc-templates --command git-summary`);

  program.parse(process.argv);

  const opts = program.opts();

  // Phase 2 will implement actual install logic. For now, print a "coming soon" stub
  // for any recognized flag so the CLI feels usable during Phase 1 testing.
  if (opts.skill)   { console.log(`[stub] Would install skill: ${opts.skill}`); }
  if (opts.hook)    { console.log(`[stub] Would install hook: ${opts.hook}`); }
  if (opts.command) { console.log(`[stub] Would install command: ${opts.command}`); }
  if (opts.mcp)     { console.log(`[stub] Would install mcp: ${opts.mcp}`); }
  if (opts.list)    { console.log('[stub] Would list all components'); }
}
```

**Step 5: Create README.md**

Create a minimal README.md at the repo root:

```markdown
# cc-templates

> Install Claude Code components with one command.

## Usage

\`\`\`bash
npx cc-templates --skill video-download
npx cc-templates --hook auto-format
npx cc-templates --command git-summary
npx cc-templates --list
\`\`\`

## Requirements

- Node.js >= 20

## License

MIT
```

**Step 6: Create .gitignore**

```
node_modules/
*.tgz
.DS_Store
```

**Anti-patterns to avoid:**
- Do NOT put any logic in bin/index.js beyond the shebang + import + run() call
- Do NOT use `require()` anywhere — project is `"type": "module"`
- Do NOT use chalk 4.x — use chalk 5.x (ESM-only)
- Do NOT hardcode the version string in src/cli.js
  </action>
  <verify>
    <automated>node /c/Development/cli/claude-templates/bin/index.js --help 2>&amp;1 | grep -q "cc-templates — Install Claude Code components" &amp;&amp; echo "HELP OK" || echo "HELP FAILED"</automated>
    <manual>Run `node bin/index.js --help` from the repo root. Confirm output contains: branded header line, Usage section, all five flags (--skill, --hook, --command, --mcp, --list), and Examples section. Also confirm `node bin/index.js --version` prints a version number.</manual>
    <sampling_rate>run after this task, before Task 2</sampling_rate>
  </verify>
  <done>
    - `node bin/index.js --help` exits 0 and prints the branded header "cc-templates — Install Claude Code components" plus all flags and Examples section
    - `node bin/index.js --version` prints "0.1.0"
    - `node bin/index.js --skill foo` prints "[stub] Would install skill: foo" (no error)
    - package.json has `"type": "module"`, correct `bin`, `files`, and `engines` fields
    - node_modules/ exists (npm install ran successfully)
  </done>
</task>

<task type="auto">
  <name>Task 2: Seed component library with frontmatter and generate components.json</name>
  <files>
    components/skills/video-download/skill.md
    components/skills/video-fetch-and-summarize/skill.md
    components/skills/video-summarizer/skill.md
    components/hooks/.gitkeep
    components/commands/.gitkeep
    components/mcp/.gitkeep
    scripts/build-catalog.js
    components.json
  </files>
  <action>
**Step 1: Create the component directory tree**

Create the following directory structure. Each skill is a subdirectory under `components/skills/`. Hook, command, and mcp directories are empty for now but must exist.

```
components/
  skills/
    video-download/
      skill.md
    video-fetch-and-summarize/
      skill.md
    video-summarizer/
      skill.md
  hooks/
    .gitkeep
  commands/
    .gitkeep
  mcp/
    .gitkeep
```

**Step 2: Write skill.md files with YAML frontmatter**

COMP-04 requires valid YAML frontmatter with at minimum `name` and `description`. Optional fields: `author`, `version`, `tags`, `requires`.

`components/skills/video-download/skill.md`:
```markdown
---
name: video-download
description: Download videos from YouTube, Instagram, TikTok, and more via yt-dlp
author: cc-templates
version: 1.0.0
tags:
  - video
  - download
  - media
requires:
  tools:
    - yt-dlp
---

# video-download

A Claude Code skill for downloading videos from popular platforms using yt-dlp.

## Usage

Ask Claude to download a video by providing the URL.

## Requirements

- `yt-dlp` must be installed and available in PATH
```

`components/skills/video-fetch-and-summarize/skill.md`:
```markdown
---
name: video-fetch-and-summarize
description: Download videos and generate AI summaries using Google Gemini
author: cc-templates
version: 1.0.0
tags:
  - video
  - download
  - summarize
  - ai
requires:
  tools:
    - yt-dlp
  env:
    - GEMINI_API_KEY
---

# video-fetch-and-summarize

A Claude Code skill that downloads videos and generates summaries using Google Gemini.

## Usage

Ask Claude to fetch and summarize a video by providing the URL.

## Requirements

- `yt-dlp` must be installed and available in PATH
- `GEMINI_API_KEY` environment variable must be set
```

`components/skills/video-summarizer/skill.md`:
```markdown
---
name: video-summarizer
description: Generate AI summaries of existing MP4 files using Google Gemini
author: cc-templates
version: 1.0.0
tags:
  - video
  - summarize
  - ai
requires:
  env:
    - GEMINI_API_KEY
---

# video-summarizer

A Claude Code skill that generates summaries of MP4 files already on disk using Google Gemini.

## Usage

Ask Claude to summarize a video file by providing the local path.

## Requirements

- `GEMINI_API_KEY` environment variable must be set
```

**Step 3: Write scripts/build-catalog.js**

This script walks `components/`, reads each component's main file, extracts YAML frontmatter, validates required fields, and writes `components.json`. For skills (directories), the main file is `skill.md`. For hooks/commands/mcp (files), iterate over files directly.

Use `import yaml from 'js-yaml'` as the default import (CJS-from-ESM pattern). If this throws at runtime with "does not provide a named export 'default'", fall back to `createRequire`:

```javascript
#!/usr/bin/env node
import { readFileSync, writeFileSync, readdirSync, statSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { createRequire } from 'node:module';

// js-yaml 4.x is CJS — import as default works in Node 20+ ESM context.
// If default import fails, createRequire fallback is used.
let yaml;
try {
  const mod = await import('js-yaml');
  yaml = mod.default;
} catch {
  const require = createRequire(import.meta.url);
  yaml = require('js-yaml');
}

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const ROOT = join(__dirname, '..');
const COMPONENT_TYPES = ['skills', 'hooks', 'commands', 'mcp'];
const REQUIRED_FIELDS = ['name', 'description'];

function extractFrontmatter(filePath) {
  if (!existsSync(filePath)) return null;
  const content = readFileSync(filePath, 'utf8');
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!match) return null;
  return yaml.load(match[1]);
}

function getMainFile(typeDir, entry) {
  const entryPath = join(typeDir, entry);
  if (statSync(entryPath).isDirectory()) {
    // Skills are directories; primary file is skill.md
    return join(entryPath, 'skill.md');
  }
  // Hooks, commands, mcp are individual files
  if (entry === '.gitkeep') return null;
  return entryPath;
}

function buildCatalog() {
  const catalog = {};
  const errors = [];

  for (const type of COMPONENT_TYPES) {
    catalog[type] = [];
    const typeDir = join(ROOT, 'components', type);

    if (!existsSync(typeDir)) {
      console.warn(`WARN: components/${type}/ does not exist — skipping`);
      continue;
    }

    for (const entry of readdirSync(typeDir)) {
      const mainFile = getMainFile(typeDir, entry);
      if (!mainFile) continue; // .gitkeep or null

      const fm = extractFrontmatter(mainFile);
      if (!fm) {
        errors.push(`${mainFile}: missing or unparseable frontmatter`);
        continue;
      }

      for (const field of REQUIRED_FIELDS) {
        if (!fm[field]) {
          errors.push(`${mainFile}: missing required field "${field}"`);
        }
      }

      catalog[type].push({
        name: fm.name ?? null,
        description: fm.description ?? null,
        author: fm.author ?? null,
        version: fm.version ?? null,
        tags: Array.isArray(fm.tags) ? fm.tags : [],
      });
    }
  }

  if (errors.length > 0) {
    console.error('\nCatalog build FAILED — fix the following errors:\n');
    for (const e of errors) console.error(`  ERROR: ${e}`);
    process.exit(1);
  }

  const outPath = join(ROOT, 'components.json');
  writeFileSync(outPath, JSON.stringify(catalog, null, 2) + '\n');
  const total = Object.values(catalog).reduce((n, arr) => n + arr.length, 0);
  console.log(`components.json written — ${total} component(s) across ${COMPONENT_TYPES.length} types`);
}

buildCatalog();
```

**Step 4: Run the build script**

```bash
node scripts/build-catalog.js
```

Confirm it exits 0 and prints a success message. Confirm `components.json` is written at the repo root.

**Step 5: Validate npm pack output**

```bash
npm pack --dry-run 2>&1
```

Audit the output:
- MUST include: `bin/index.js`, `src/cli.js`, `components.json`, `package.json`, `README.md`
- MUST NOT include: any path starting with `components/`, `scripts/`, `.planning/`, `node_modules/`

If any unwanted paths appear, update the `files` field in package.json and re-run.

**Anti-patterns to avoid:**
- Do NOT use gray-matter for frontmatter parsing (ESM interop issues)
- Do NOT ship `components/` directory inside the npm package — stays on GitHub, fetched at runtime
- Do NOT use regex alone for multi-line YAML values — use js-yaml for parsing
  </action>
  <verify>
    <automated>node /c/Development/cli/claude-templates/scripts/build-catalog.js &amp;&amp; node -e "import('/c/Development/cli/claude-templates/components.json', {assert:{type:'json'}}).then(m=>{const c=m.default;console.log('skills:',c.skills.length,'hooks:',c.hooks.length,'commands:',c.commands.length,'mcp:',c.mcp.length);if(c.skills.length===3)console.log('CATALOG OK');else console.log('CATALOG WRONG COUNT');})" 2>&amp;1 || node -e "const c=JSON.parse(require('fs').readFileSync('components.json','utf8'));console.log('skills:',c.skills.length);if(c.skills.length===3)console.log('CATALOG OK');"</automated>
    <manual>
      1. Run `node scripts/build-catalog.js` — confirm exits 0 with success message
      2. Inspect `components.json` — confirm top-level keys are skills, hooks, commands, mcp; skills array has 3 entries with name, description, author, version, tags fields
      3. Run `npm pack --dry-run` — confirm NO paths starting with `components/` appear in output
      4. Open each `components/skills/*/skill.md` and confirm valid `---` frontmatter block at top with name and description fields
    </manual>
    <sampling_rate>run after this task completes</sampling_rate>
  </verify>
  <done>
    - `node scripts/build-catalog.js` exits 0 and prints success message
    - `components.json` at repo root has `{ skills: [3 entries], hooks: [], commands: [], mcp: [] }` structure
    - Each skill entry has: name, description, author, version, tags fields
    - `npm pack --dry-run` does NOT list any `components/` paths
    - All three skill.md files have valid YAML frontmatter with name and description (COMP-04 satisfied)
    - components.json is committed and would ship inside the npm package (COMP-05 satisfied)
  </done>
</task>

</tasks>

<verification>
After both tasks complete, run this full verification sequence from the repo root:

1. `node bin/index.js --help` — prints branded header, all flags, Examples section
2. `node bin/index.js --version` — prints "0.1.0"
3. `node bin/index.js --skill video-download` — prints stub message (no error)
4. `node scripts/build-catalog.js` — exits 0
5. `cat components.json | node -e "const c=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));console.log(Object.keys(c),c.skills.map(s=>s.name))"` — shows all 4 type keys and 3 skill names
6. `npm pack --dry-run 2>&1 | grep components/` — should produce NO output (no component source files in tarball)

Phase 1 success criteria from ROADMAP.md:
- [ ] `npx cc-templates --help` prints usage without errors
- [ ] `npm pack --dry-run` lists only bin/, src/, components.json, package.json, README
- [ ] `components.json` lists all components with name, description, author fields
- [ ] All component source files have valid YAML frontmatter with name and description
</verification>

<success_criteria>
- `node bin/index.js --help` exits 0 with branded header "cc-templates — Install Claude Code components" and all five flags visible
- `npm pack --dry-run` output contains NO paths starting with `components/`, `scripts/`, or `.planning/`
- `components.json` exists at repo root with schema `{ skills: [...], hooks: [], commands: [], mcp: [] }` where skills array has 3 entries
- All three skill.md files have `---` frontmatter with `name:` and `description:` fields (COMP-04)
- `npm run build` regenerates components.json cleanly (exit 0) — proving COMP-05 is reproducible
- npm name `cc-templates` was confirmed available before scaffold was created
</success_criteria>

<output>
After completion, create `.planning/phases/01-scaffold/01-01-SUMMARY.md` documenting:
- Whether cc-templates npm name was available
- Actual files created and their sizes/line counts
- Any deviations from the plan (e.g., js-yaml import fallback needed)
- components.json contents (skills array)
- Result of `npm pack --dry-run` (pass/fail + any surprises)
</output>
