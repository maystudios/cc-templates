---
phase: 02.1-typescript-migration
plan: "02"
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - src/types.ts
  - src/catalog.ts
  - src/output.ts
  - src/fetch.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "src/types.ts exports InstallOptions, CatalogEntry, ComponentType, and GitHubContentsItem interfaces"
    - "src/catalog.ts compiles without errors and exports getAvailable and validateName with proper TypeScript types"
    - "src/output.ts compiles without errors with typed parameters"
    - "src/fetch.ts compiles without errors with typed parameters and return types"
    - "All .js source files in src/ removed/renamed once .ts equivalents exist"
  artifacts:
    - path: "src/types.ts"
      provides: "Shared TypeScript interfaces used across all modules"
      exports: ["InstallOptions", "CatalogEntry", "ComponentType", "GitHubContentsItem"]
    - path: "src/catalog.ts"
      provides: "Catalog lookup functions with TypeScript types"
      exports: ["getAvailable", "validateName"]
    - path: "src/output.ts"
      provides: "Output formatting functions with TypeScript types"
    - path: "src/fetch.ts"
      provides: "GitHub API fetch functions with TypeScript types"
  key_links:
    - from: "src/catalog.ts"
      to: "src/types.ts"
      via: "import { CatalogEntry, ComponentType }"
      pattern: "import.*types\\.js"
    - from: "src/fetch.ts"
      to: "src/types.ts"
      via: "import { GitHubContentsItem }"
      pattern: "import.*types\\.js"
---

<objective>
Create the shared types file (src/types.ts) and migrate the three simpler source modules: catalog.ts, output.ts, and fetch.ts. These have no complex CJS interop and form the foundation for the main orchestration files migrated in later plans.

Purpose: Establishes shared interfaces once so all other modules can import them. Migrating the simpler modules first validates the tsconfig setup before tackling complex files.
Output: src/types.ts, src/catalog.ts, src/output.ts, src/fetch.ts (old .js files removed).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-typescript-migration/02.1-CONTEXT.md
@.planning/phases/02.1-typescript-migration/02.1-RESEARCH.md
@.planning/phases/02.1-typescript-migration/02.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/types.ts with shared interfaces</name>
  <files>src/types.ts</files>
  <action>
Create `src/types.ts` as a NEW file (do not rename an existing file). This is the single source of truth for shared types across the entire codebase.

```typescript
// src/types.ts

/**
 * Options parsed from CLI flags by commander.
 * All fields are optional — the user may combine any subset.
 */
export interface InstallOptions {
  skill?: string;
  agent?: string;
  command?: string;
  hook?: string;
  mcp?: string;
  force?: boolean;
  global?: boolean;
  yes?: boolean;
  verbose?: boolean;
  list?: boolean;
}

/**
 * Component type string values matching CLI flags.
 */
export type ComponentType = 'skill' | 'agent' | 'command' | 'hook' | 'mcp';

/**
 * Entry from components.json catalog.
 */
export interface CatalogEntry {
  name: string | null;
  description: string | null;
  author: string | null;
  version: string | null;
  tags: string[];
}

/**
 * Item from GitHub Contents API v3 response.
 * https://docs.github.com/en/rest/repos/contents
 */
export interface GitHubContentsItem {
  type: 'file' | 'dir' | 'symlink' | 'submodule';
  name: string;
  path: string;
  url: string;
  download_url: string | null;
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit --project tsconfig.json 2>&1 | grep "src/types" || echo "types.ts: no errors"</automated>
  </verify>
  <done>src/types.ts exists and exports InstallOptions, ComponentType, CatalogEntry, GitHubContentsItem. tsc --noEmit reports no errors for this file.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate catalog.ts, output.ts, fetch.ts</name>
  <files>src/catalog.ts, src/output.ts, src/fetch.ts</files>
  <action>
Rename each .js file to .ts AND add TypeScript types. Delete the old .js files after creating the .ts equivalents.

**CRITICAL import rule for NodeNext ESM:** All relative imports MUST use `.js` extension (not `.ts`). TypeScript resolves `.ts` source but Node.js sees compiled `.js` at runtime. Example: `import { CatalogEntry } from './types.js'` — the `.js` extension is correct even though the source file is `types.ts`.

**Do NOT change** the `const __dirname = dirname(fileURLToPath(import.meta.url))` pattern — it is already correct and TypeScript-compatible.

---

**src/catalog.ts** — Key changes from catalog.js:
- Add `import { CatalogEntry, ComponentType } from './types.js';` at top
- Type `getCatalogKey(type: ComponentType): string`
- Type `getAvailable(type: ComponentType): CatalogEntry[]`
- Type `validateName(type: ComponentType, name: string): CatalogEntry`
- Remove JSDoc `@param`/`@returns` comments (types are now in signatures)
- Keep inline comments explaining logic

**src/output.ts** — Read the current `src/output.js` first, then:
- Rename to `.ts`, fix all parameter types (likely string/boolean parameters)
- Import `InstallOptions` from `'./types.js'` if output.js uses the opts object
- Add return type annotations to all exported functions

**src/fetch.ts** — Read the current `src/fetch.js` first, then:
- Rename to `.ts`, fix all parameter types
- Import `GitHubContentsItem` from `'./types.js'` for GitHub API response typing
- The fetch response body from GitHub Contents API is `GitHubContentsItem[]` — type it accordingly
- Add return type annotations; async functions returning promises need `Promise<T>` return types

After creating all three .ts files, delete the three old .js files:
- Delete `src/catalog.js`
- Delete `src/output.js`
- Delete `src/fetch.js`

Run `npx tsc --noEmit` to verify all three files compile without errors. Fix any type errors before proceeding. For genuinely hard-to-type cases, use explicit `any` with a `// TODO: type this properly` comment — do NOT use `@ts-ignore`.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | grep -E "src/(catalog|output|fetch)" | grep -v "^$" || echo "catalog/output/fetch: no tsc errors"</automated>
    <manual>Confirm src/catalog.js, src/output.js, src/fetch.js no longer exist. Confirm src/catalog.ts, src/output.ts, src/fetch.ts exist.</manual>
  </verify>
  <done>src/catalog.ts, src/output.ts, src/fetch.ts exist with TypeScript types. Old .js files deleted. npx tsc --noEmit reports no errors for these three files (ignoring errors in files not yet migrated).</done>
</task>

</tasks>

<verification>
Run: `npx tsc --noEmit 2>&1 | grep -E "src/(types|catalog|output|fetch)"` — should show no errors for these files (other src/ files not yet migrated may still have errors at this stage — that is expected)
Run: `ls src/*.ts` — should list types.ts, catalog.ts, output.ts, fetch.ts
Run: `ls src/*.js` — should NOT list catalog.js, output.js, fetch.js (cli.js and install.js still exist at this stage)
</verification>

<success_criteria>
- src/types.ts exports all four interfaces/types
- src/catalog.ts, src/output.ts, src/fetch.ts exist with full TypeScript types, old .js files deleted
- All relative imports use .js extension
- __dirname shim pattern unchanged
- tsc --noEmit has zero errors for the four migrated files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-typescript-migration/02.1-02-SUMMARY.md`
</output>
