# Phase 2.1: TypeScript Migration - Research

**Researched:** 2026-02-24
**Domain:** TypeScript 5.x, tsc build pipeline, ESLint v9 flat config, Node.js ESM
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Build Toolchain
- Use **tsc** (TypeScript compiler) as the build tool — no esbuild or tsup
- Output format: **ESM** (matches existing `"type": "module"` in package.json)
- Compiled output goes to **`dist/`** — `package.json` ships `dist/`, `components.json`, `README.md` (remove `src/` from `files`)
- Emit **declaration files** (`.d.ts`) for type information and future library use
- `bin/index.js` updated to import from `dist/` (e.g., `import '../dist/index.js'`)

#### TypeScript Strictness
- Enable **full strict mode** (`strict: true` in tsconfig)
- Target **Node 22** — update `engines` field to `>=22`
- tsconfig settings: `target: "ES2023"`, `module: "NodeNext"`, `moduleResolution: "NodeNext"`
- Hard-to-type cases: use `any` with `// TODO: type this properly` comments — clean up iteratively
- **No path aliases** — keep relative imports throughout

#### ESLint Configuration
- Base rule set: **`@typescript-eslint/recommended`**
- Config format: **flat config** (`eslint.config.js`) — ESLint v9+ standard
- Scope: **error detection only** — no Prettier integration, no style rules
- ESLint runs as a **separate `npm run lint` script** — does not block the build

#### Migration Strategy
- Convert **all `src/**/*.js` files at once** — rename to `.ts`, then fix type errors
- **Convert JSDoc to TypeScript types** — replace `@param`/`@returns` with proper TS parameter and return types; remove JSDoc once types are in code
- **Migrate tests to TypeScript** as well — all test files become `.test.ts`
- No incremental/allowJs approach — full migration in one pass

### Claude's Discretion

From `<specifics>`:
- The `scripts/build-catalog.js` file (if not in `src/`) may stay as JS if it's a standalone build script — Claude should check and decide
- `bin/index.js` stays as `.js` (it's the entry point shim), but it imports from compiled `dist/`

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope.
</user_constraints>

---

## Summary

This phase converts the existing 9-file JavaScript codebase (`src/cli.js`, `src/catalog.js`, `src/fetch.js`, `src/install.js`, `src/output.js`, and four `src/installers/*.js` files) to TypeScript. The project is already ESM (`"type": "module"` in package.json), which removes the CommonJS-to-ESM complexity but introduces one critical requirement: all relative imports in TypeScript source files MUST use `.js` extensions (not `.ts`), because Node.js ESM resolves the compiled output, not the source.

The locked toolchain is `tsc` with `module: "NodeNext"` and `moduleResolution: "NodeNext"` — the current best practice for Node.js ESM-only CLI packages (as of TypeScript 5.7+/5.9). TypeScript 5.7 introduced `rewriteRelativeImportExtensions` which allows writing `.ts` extension imports in source that get rewritten to `.js` in output, but the conventional approach for NodeNext is to write `.js` extensions throughout source files. Since there are no existing tests (the package.json has no test script), Wave 0 for this phase must establish a test harness.

The codebase is small enough for a full atomic migration — all files at once, no `allowJs` bridge. The four dependency packages (`chalk`, `commander`, `js-yaml`, `write-file-atomic`) have varying TypeScript situations: `commander` 14.x ships bundled types; `chalk` 5.x ships bundled types; `@types/js-yaml` and `@types/write-file-atomic` must be installed separately.

**Primary recommendation:** Install TypeScript 5.x + `@typescript-eslint` packages; write `.js` extensions in all import statements in `.ts` source files; use `rewriteRelativeImportExtensions: true` in tsconfig to allow the alternative `.ts`-extension style if preferred; compile `src/` to `dist/`; leave `bin/index.js` and `scripts/build-catalog.js` as plain JS files.

---

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `typescript` | `^5.9` | Compiler and type checker | Latest stable; 5.7+ has `rewriteRelativeImportExtensions` for ESM; 5.9 is current as of Feb 2026 |
| `@types/node` | `^22` | Node.js built-in type definitions | Must match `engines: >=22`; provides types for `fs`, `path`, `os`, `url`, `module` |

### Supporting (ESLint)

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `eslint` | `^9` | Linter runner | Required; v9 is current; flat config is the default |
| `typescript-eslint` | `^8` | TypeScript parser + rules for ESLint | The unified package replacing separate `@typescript-eslint/parser` + `@typescript-eslint/eslint-plugin`; v8 targets ESLint v9 |
| `@eslint/js` | `^9` | ESLint's core recommended rules | Provides `eslint.configs.recommended` used in flat config |

### Dependency Type Stubs (devDependencies)

| Library | Version | Notes |
|---------|---------|-------|
| `@types/js-yaml` | `^4` | js-yaml 4.x does NOT ship bundled types |
| `@types/write-file-atomic` | `^4` | write-file-atomic does NOT ship bundled types; latest @types version is 4.0.3 |

**Bundled types (no @types needed):**
- `commander` 14.x — ships its own `.d.ts`
- `chalk` 5.x — ships its own `.d.ts`

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `tsc` | `tsup` / `esbuild` | Locked decision — tsc is explicit, no bundler magic |
| `typescript-eslint` unified | Separate `@typescript-eslint/parser` + `@typescript-eslint/eslint-plugin` | Older split-package approach; unified `typescript-eslint` is the current recommendation as of v8 |
| `.js` extensions in imports | `rewriteRelativeImportExtensions: true` | Either works; `.js` extension convention requires no extra compiler flag; `rewriteRelativeImportExtensions` lets you write `.ts` extensions in source |

**Installation:**

```bash
npm install --save-dev typescript @types/node@22 @types/js-yaml @types/write-file-atomic eslint @eslint/js typescript-eslint
```

---

## Architecture Patterns

### Recommended Project Structure

```
claude-templates/
├── src/                      # TypeScript source (renamed from .js to .ts)
│   ├── cli.ts
│   ├── catalog.ts
│   ├── fetch.ts
│   ├── install.ts
│   ├── output.ts
│   └── installers/
│       ├── agent.ts
│       ├── command.ts
│       ├── hook.ts
│       └── skill.ts
├── dist/                     # Compiled output (git-ignored, npm-shipped)
│   ├── cli.js
│   ├── catalog.js
│   ├── ...
│   └── installers/
├── bin/
│   └── index.js              # Entry shim — stays .js, imports from dist/
├── scripts/
│   └── build-catalog.js      # Stays .js (standalone script, not in src/)
├── tsconfig.json             # Build tsconfig (src/ → dist/)
├── eslint.config.js          # ESLint v9 flat config
├── package.json
└── components.json
```

**Note on `scripts/build-catalog.js`:** This file lives outside `src/` and is a standalone Node.js script, not imported by the CLI. It should stay as plain `.js`. The `tsc` build is scoped to `src/` only.

### Pattern 1: tsconfig.json for NodeNext ESM CLI

**What:** Full tsconfig targeting Node 22, NodeNext module system, strict mode, emitting to `dist/` with declaration files.

**When to use:** This exact config for this project.

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2023",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "rootDir": "./src",
    "outDir": "./dist",
    "declaration": true,
    "declarationMap": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**Key flags explained:**
- `"module": "NodeNext"` — tells tsc the output will be consumed by Node.js ESM; enforces `.js` extension requirements on relative imports
- `"moduleResolution": "NodeNext"` — must match `module`; understands package.json `exports` fields
- `"resolveJsonModule": true` — required because `catalog.js` and `cli.js` read `package.json`/`components.json` (but note: importing JSON files in ESM with NodeNext requires `import ... assert { type: 'json' }` or use `readFileSync` — the existing code uses `readFileSync`, so this is fine)
- `"skipLibCheck": true` — avoids errors in `.d.ts` files from dependencies
- `"declarationMap": true` — enables "go to source" IDE navigation through `.d.ts` files

### Pattern 2: Import Paths in TypeScript Source (NodeNext Critical Rule)

**What:** With `module: "NodeNext"`, all relative imports MUST include `.js` extension. TypeScript resolves `.ts` source files but emits `.js`; the `.js` extension in the import is what Node.js will see at runtime.

**When to use:** Every relative import in every `.ts` file.

```typescript
// CORRECT — use .js extension (resolves to .ts during compilation, .js at runtime)
import { runInstall } from './install.js';
import { output } from '../output.js';
import { validateName } from '../catalog.js';

// WRONG — tsc with NodeNext will error on extensionless imports
import { runInstall } from './install';
```

**Alternative with `rewriteRelativeImportExtensions`:** If you add `"rewriteRelativeImportExtensions": true` to tsconfig, you can write `.ts` extensions in imports and tsc rewrites them to `.js` in output. This is valid but non-conventional. The `.js` extension approach is the standard pattern.

### Pattern 3: ESLint v9 Flat Config for TypeScript

**What:** `eslint.config.js` using the unified `typescript-eslint` package with `@typescript-eslint/recommended` rules.

```javascript
// eslint.config.js
// Source: https://typescript-eslint.io/getting-started/
import eslint from '@eslint/js';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  eslint.configs.recommended,
  tseslint.configs.recommended,
);
```

**Notes:**
- Use `eslint.config.js` (not `.mjs`) because package.json has `"type": "module"` — `.js` files are already ESM
- `tseslint.config()` is the helper function from the `typescript-eslint` package
- `tseslint.configs.recommended` enables the equivalent of `@typescript-eslint/recommended` rules

### Pattern 4: package.json Changes

```json
{
  "scripts": {
    "build": "tsc",
    "lint": "eslint src/",
    "prepublishOnly": "npm run build"
  },
  "files": [
    "dist/",
    "bin/",
    "components.json",
    "README.md"
  ],
  "engines": {
    "node": ">=22"
  }
}
```

**Changes from current:**
- `"build": "tsc"` (was `"node scripts/build-catalog.js"` — this becomes a separate step or integrated differently)
- Add `"lint": "eslint src/"`
- `"files"`: replace `"src/"` with `"dist/"` — compiled output ships, not source
- `"engines"`: update from `>=20` to `>=22`

**IMPORTANT:** The current `"build"` script runs `build-catalog.js`. After migration, `npm run build` must: (1) generate `components.json` AND (2) compile TypeScript. Options:
- Sequence them: `"build": "node scripts/build-catalog.js && tsc"`
- Or separate: `"catalog": "node scripts/build-catalog.js"`, `"build": "tsc"`, `"prepublishOnly": "npm run catalog && npm run build"`

### Pattern 5: bin/index.js Update

```javascript
// bin/index.js — stays as plain JS, updates import path
#!/usr/bin/env node
import { run } from '../dist/cli.js';  // was: '../src/cli.js'

run().catch(err => {
  console.error(err.message);
  process.exit(1);
});
```

### Pattern 6: Typing the Existing Codebase

**opts parameter (install.js, installers/*.js):** The `opts` object currently typed as `{object}` in JSDoc needs a real interface:

```typescript
// Define once, import where needed
export interface InstallOptions {
  skill?: string;
  agent?: string;
  command?: string;
  hook?: string;
  mcp?: string;
  force?: boolean;
  global?: boolean;
  yes?: boolean;
  verbose?: boolean;
  list?: boolean;
}
```

**GitHub API response (installers/skill.js):** The `items` from `res.json()` is an array of GitHub Contents API objects:

```typescript
interface GitHubContentsItem {
  type: 'file' | 'dir' | 'symlink' | 'submodule';
  name: string;
  path: string;
  url: string;
  download_url: string | null;
}
```

**CatalogEntry (catalog.js):**

```typescript
interface CatalogEntry {
  name: string | null;
  description: string | null;
  author: string | null;
  version: string | null;
  tags: string[];
}

type ComponentType = 'skill' | 'agent' | 'command' | 'hook' | 'mcp';
```

**write-file-atomic CJS interop:** The existing `try/catch` import pattern will need typing:

```typescript
import type writeFileAtomicType from 'write-file-atomic';
let writeFileAtomic: typeof writeFileAtomicType;
// ... existing try/catch pattern works; add type annotation
```

### Anti-Patterns to Avoid

- **Extensionless relative imports:** `import { x } from './utils'` — fails at runtime with NodeNext; always use `'./utils.js'`
- **`@ts-ignore` instead of `any` with TODO:** Use `// TODO: type this properly` with explicit `any` annotation; `@ts-ignore` suppresses errors silently without leaving a searchable marker
- **Importing JSON directly as ESM module:** The existing code uses `readFileSync` for JSON (correct). Do not switch to `import data from './data.json' assert { type: 'json' }` — it requires additional tsconfig flags and has cross-version Node.js compatibility issues
- **Adding `--allowJs` as a stepping stone:** Locked decision is full migration in one pass — `allowJs` is explicitly ruled out
- **`esModuleInterop: true`:** Not needed for this project; the existing code already handles CJS interop manually for `js-yaml` and `write-file-atomic`; adding `esModuleInterop` can cause unexpected behavior with NodeNext

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Type checking | Manual runtime type guards | `strict: true` in tsc | Compiler catches class of errors at build time; free |
| Linting rule set | Custom ESLint rules | `tseslint.configs.recommended` | Battle-tested set of ~40 rules for TypeScript; covers implicit any, unused vars, etc. |
| GitHub API response types | Custom interfaces from scratch | Use the interfaces from research (Pattern 6 above) | These match the actual GitHub Contents API v3 contract |
| CJS-to-ESM shim for write-file-atomic | Custom wrapper | Keep the existing `createRequire` try/catch pattern | Already works; adding TypeScript types is the only change needed |

**Key insight:** This is a type-annotation-only migration — the runtime behavior does not change. Don't introduce new abstractions while migrating.

---

## Common Pitfalls

### Pitfall 1: Missing `.js` Extensions on Relative Imports

**What goes wrong:** tsc compiles but `npx cc-templates --help` fails with `ERR_MODULE_NOT_FOUND` because Node.js ESM cannot resolve extensionless relative imports.

**Why it happens:** tsc with `module: "NodeNext"` does NOT add `.js` extensions automatically. The extension in the source import is passed through verbatim to the output.

**How to avoid:** Rename all imports immediately when renaming files to `.ts`. Use `.js` extension in every relative import — even though the source file is `.ts`, the import references the compiled output path.

**Warning signs:** `tsc` succeeds but `node dist/cli.js` fails at runtime with `Cannot find module`.

### Pitfall 2: `__dirname` is Already Handled — Don't Break It

**What goes wrong:** Refactoring `__dirname` usage unnecessarily introduces bugs.

**Why it happens:** The existing code already correctly uses the ESM `import.meta.url` pattern:
```javascript
const __dirname = dirname(fileURLToPath(import.meta.url));
```
This pattern is correct and TypeScript-compatible. It must NOT be changed.

**How to avoid:** Leave the `__dirname` shim pattern as-is in every file that uses it (`catalog.ts`, `cli.ts`, `scripts/build-catalog.js`). TypeScript understands `import.meta.url` in NodeNext mode.

**Warning signs:** Changing to `import.meta.dirname` (Node 22 only, breaks the pattern) or removing `fileURLToPath`.

### Pitfall 3: `build` Script Collision

**What goes wrong:** After migration, `npm run build` only runs `tsc`, but `components.json` is no longer generated — `npm pack` produces a broken package.

**Why it happens:** The current `"build"` script runs `build-catalog.js`. After migration, `"build"` becomes `"tsc"`. If the catalog script is lost from the build chain, the package ships without `components.json`.

**How to avoid:** Wire both into the `prepublishOnly` chain. Recommended:
```json
"scripts": {
  "build": "node scripts/build-catalog.js && tsc",
  "prepublishOnly": "npm run build"
}
```

**Warning signs:** `npm pack --dry-run` shows `components.json` missing, or `npx cc-templates --list` crashes.

### Pitfall 4: CJS Dependencies (`js-yaml`, `write-file-atomic`) Type Issues

**What goes wrong:** Type errors or `any` implicit types when importing CJS packages with the try/catch interop pattern.

**Why it happens:** The try/catch dynamic import pattern loses TypeScript's ability to infer types from the import.

**How to avoid:**
- Install `@types/js-yaml` and `@types/write-file-atomic`
- Use `import type` to pull in the type for annotation:
  ```typescript
  import type { dump, load } from 'js-yaml';
  let yaml: { dump: typeof dump; load: typeof load };
  ```
- Or simply type the variable after assignment: `const yaml = mod.default as typeof import('js-yaml').default`

**Warning signs:** ESLint reporting `@typescript-eslint/no-explicit-any` on the interop variables.

### Pitfall 5: `skipLibCheck` Masking Real Issues

**What goes wrong:** `skipLibCheck: true` hides type errors in `.d.ts` files from dependencies, potentially masking real issues.

**Why it happens:** Some older `@types/*` packages have internal type errors. `skipLibCheck` is standard practice to avoid those false positives.

**How to avoid:** Use `skipLibCheck: true` (standard, necessary) but be aware it only skips `.d.ts` file checking — it does NOT skip checking your own source files.

**Warning signs:** None — this is intentional and correct for this project.

### Pitfall 6: `dist/` Not in `.gitignore`

**What goes wrong:** Compiled output is committed to git, causing merge conflicts and repo bloat.

**Why it happens:** `dist/` does not exist yet, so it may not be in `.gitignore`.

**How to avoid:** Add `dist/` to `.gitignore` as part of Wave 0 setup.

**Warning signs:** `git status` shows `dist/*.js` as untracked files after first `npm run build`.

### Pitfall 7: `resolveJsonModule` with NodeNext and JSON imports

**What goes wrong:** Adding `resolveJsonModule: true` to tsconfig causes errors if code tries to do `import pkg from '../package.json'` in NodeNext mode.

**Why it happens:** NodeNext requires `assert { type: 'json' }` for JSON imports, and many Node.js versions have varying support for import assertions.

**How to avoid:** The existing codebase uses `readFileSync` + `JSON.parse` for reading JSON files — keep that pattern. Set `resolveJsonModule: true` in tsconfig for correctness, but do NOT switch any file to use JSON import syntax.

**Warning signs:** New `import X from './file.json'` statements appearing during migration.

---

## Code Examples

Verified patterns from official sources and codebase analysis:

### tsconfig.json (complete)

```json
// Source: https://www.typescriptlang.org/tsconfig + https://2ality.com/2025/02/typescript-esm-packages.html
{
  "compilerOptions": {
    "target": "ES2023",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "rootDir": "./src",
    "outDir": "./dist",
    "declaration": true,
    "declarationMap": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### eslint.config.js (complete)

```javascript
// Source: https://typescript-eslint.io/getting-started/
import eslint from '@eslint/js';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  eslint.configs.recommended,
  tseslint.configs.recommended,
);
```

### src/cli.ts (migration example — key changes only)

```typescript
// BEFORE (cli.js)
import { runInstall } from './install.js';

// AFTER (cli.ts) — same import path (.js extension kept, NOT changed to .ts)
import { runInstall } from './install.js';

// JSDoc removed; types added directly to function signature
export async function run(): Promise<void> {
  // ...
  const opts = program.opts<InstallOptions>();
  // ...
}
```

### src/catalog.ts (migration example — typing JSDoc)

```typescript
// BEFORE (JSDoc)
/**
 * @param {string} type - 'skill' | 'agent' | 'command' | 'hook' | 'mcp'
 * @returns {Array} array of catalog entries
 */
export function getAvailable(type) {

// AFTER (TypeScript types)
export type ComponentType = 'skill' | 'agent' | 'command' | 'hook' | 'mcp';

export interface CatalogEntry {
  name: string | null;
  description: string | null;
  author: string | null;
  version: string | null;
  tags: string[];
}

export function getAvailable(type: ComponentType): CatalogEntry[] {
```

### src/installers/hook.ts (write-file-atomic CJS interop typing)

```typescript
// Retain the existing try/catch pattern; add type annotation
import type { default as WriteFileAtomic } from 'write-file-atomic';

let writeFileAtomic: typeof WriteFileAtomic;
try {
  const mod = await import('write-file-atomic');
  writeFileAtomic = mod.default;
} catch {
  const { createRequire } = await import('node:module');
  const require = createRequire(import.meta.url);
  writeFileAtomic = require('write-file-atomic');
}
```

### Shared InstallOptions interface

```typescript
// src/types.ts (new file — shared types)
export interface InstallOptions {
  skill?: string;
  agent?: string;
  command?: string;
  hook?: string;
  mcp?: string;
  force?: boolean;
  global?: boolean;
  yes?: boolean;
  verbose?: boolean;
  list?: boolean;
}
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `@typescript-eslint/parser` + `@typescript-eslint/eslint-plugin` (separate packages) | `typescript-eslint` (unified package) | v8.0 (2024) | One package install instead of two; same rules |
| ESLint `.eslintrc.*` format | ESLint flat config (`eslint.config.js`) | ESLint v9 (2024) | Default since v9; `tseslint.config()` helper works with it |
| `"module": "ES2022"` for Node.js ESM | `"module": "NodeNext"` | TypeScript 4.7 (2022), stable in 5.x | Correct Node.js module resolution semantics; enforces `.js` extensions |
| Separate `tsconfig.build.json` to exclude tests | Single `tsconfig.json` with `exclude` | N/A | Simpler; this project has no tests yet |
| `rewriteRelativeImportExtensions: false` (default) | Optional: `rewriteRelativeImportExtensions: true` | TypeScript 5.7 (Nov 2024) | Allows writing `.ts` extension in imports; purely an authoring convenience |

**Deprecated/outdated:**
- `@types/chalk`: chalk 5.x ships its own types — do NOT install `@types/chalk`
- `@types/commander`: commander 14.x ships its own types — do NOT install `@types/commander`
- `"allowJs": true` + incremental migration: locked out of scope; full migration in one pass
- ESLint `eslintrc.*` format: obsolete in ESLint v9; flat config is the default

---

## Open Questions

1. **`scripts/build-catalog.js` stays as JS — but needs `@types/js-yaml`?**
   - What we know: `build-catalog.js` is plain JS, uses `js-yaml` for YAML parsing. It is not compiled by `tsc`.
   - What's unclear: Should `@types/js-yaml` be in devDependencies for the JS script (no — types are only consumed by tsc), or is it only needed for the TS source files?
   - Recommendation: Install `@types/js-yaml` in devDependencies for the TS source files. `build-catalog.js` continues to run as plain JS without type checking — no change needed.

2. **Are there existing tests to migrate?**
   - What we know: `package.json` has no `test` script; no test files found in the project. The success criteria includes "npm test passes — all existing behaviors verified unchanged."
   - What's unclear: Does "npm test" mean a new test harness must be created, or does it mean some other verification mechanism?
   - Recommendation: Wave 0 of this phase must create a minimal test harness (e.g., node:test or vitest) and smoke tests verifying `--help` output and build artifacts. The success criterion implies tests MUST exist post-migration.

3. **How to handle `json` type for catch blocks (`catch {}` no-binding)?**
   - What we know: Several files use `catch {}` (empty catch) and `catch (e)` without typing the error. With `strict: true`, `useUnknownInCatchVariables` is enabled — `e` is typed as `unknown`.
   - What's unclear: Some catch blocks re-use `err.message` without narrowing.
   - Recommendation: Add `if (err instanceof Error)` guard before `err.message`, or cast: `(err as Error).message`. Use `any` with TODO comment for complex cases.

---

## Sources

### Primary (HIGH confidence)
- https://typescript-eslint.io/getting-started/ — exact npm packages and eslint.config.js syntax for ESLint v9 flat config with TypeScript
- https://www.typescriptlang.org/tsconfig/moduleResolution.html — NodeNext module resolution specification
- https://2ality.com/2025/02/typescript-esm-packages.html — verified tsconfig settings for ESM npm packages with tsc (2025)
- https://devblogs.microsoft.com/typescript/announcing-typescript-5-7/ — `rewriteRelativeImportExtensions` feature documentation
- https://www.npmjs.com/package/@types/write-file-atomic — confirmed @types package exists (v4.0.3)
- https://www.npmjs.com/package/@types/js-yaml — confirmed @types package exists (v4.x)

### Secondary (MEDIUM confidence)
- https://typescript-eslint.io/blog/announcing-typescript-eslint-v8/ — v8 targets ESLint v9; unified package
- https://dev.to/a0viedo/nodejs-typescript-and-esm-it-doesnt-have-to-be-painful-438e — ESM + TypeScript pitfalls verified against official behavior
- commander.js npm page (https://www.npmjs.com/package/commander) — confirmed v14 ships bundled types; `@types/commander` is a stub
- chalk npm page (https://github.com/chalk/chalk/releases/v5.0.0) — confirmed v5 ships bundled types; ESM-only

### Tertiary (LOW confidence)
- write-file-atomic CJS vs ESM status — could not definitively confirm v7 module format from npm/GitHub pages; treat as CJS (the README shows `require()` syntax and existing code uses `createRequire` fallback — this is the safe assumption)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — verified via official docs and npm pages
- Architecture: HIGH — based on actual codebase inspection and official TypeScript/ESLint docs
- Pitfalls: HIGH — sourced from TypeScript official docs and known NodeNext constraints

**Research date:** 2026-02-24
**Valid until:** 2026-09-24 (stable tooling — TypeScript and ESLint are slow-moving for project-level config)
