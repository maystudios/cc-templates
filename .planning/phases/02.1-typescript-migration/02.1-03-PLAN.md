---
phase: 02.1-typescript-migration
plan: "03"
type: execute
wave: 3
depends_on: ["02.1-02"]
files_modified:
  - src/installers/agent.ts
  - src/installers/command.ts
  - src/installers/hook.ts
  - src/installers/skill.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "All four installer files are .ts with proper TypeScript types"
    - "write-file-atomic CJS interop is preserved and typed correctly in hook.ts"
    - "GitHubContentsItem interface is used for GitHub API responses in skill.ts"
    - "InstallOptions is used for the opts parameter in all four installer files"
    - "Old .js installer files are deleted"
  artifacts:
    - path: "src/installers/agent.ts"
      provides: "Agent installer with TypeScript types"
    - path: "src/installers/command.ts"
      provides: "Command installer with TypeScript types"
    - path: "src/installers/hook.ts"
      provides: "Hook installer with TypeScript types and CJS interop"
    - path: "src/installers/skill.ts"
      provides: "Skill installer with GitHubContentsItem typing"
  key_links:
    - from: "src/installers/hook.ts"
      to: "write-file-atomic"
      via: "try/catch CJS interop with type annotation"
      pattern: "WriteFileAtomic"
    - from: "src/installers/skill.ts"
      to: "src/types.ts"
      via: "import { GitHubContentsItem }"
      pattern: "GitHubContentsItem"
    - from: "src/installers/*.ts"
      to: "src/types.ts"
      via: "import { InstallOptions }"
      pattern: "InstallOptions"
---

<objective>
Migrate the four installer files (agent.ts, command.ts, hook.ts, skill.ts) from JavaScript to TypeScript. These files have the most complex typing needs: hook.ts uses a CJS interop pattern for write-file-atomic, and skill.ts processes GitHub Contents API responses.

Purpose: Completing the installer layer enables install.ts migration in plan 04, which depends on all installers being typed.
Output: src/installers/agent.ts, command.ts, hook.ts, skill.ts (old .js files deleted).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-typescript-migration/02.1-CONTEXT.md
@.planning/phases/02.1-typescript-migration/02.1-RESEARCH.md
@.planning/phases/02.1-typescript-migration/02.1-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate agent.ts and command.ts</name>
  <files>src/installers/agent.ts, src/installers/command.ts</files>
  <action>
Read `src/installers/agent.js` and `src/installers/command.js` first to understand the current implementation before making any changes.

For each file:
1. Create the `.ts` version with TypeScript types
2. Delete the old `.js` file

**CRITICAL import rule:** All relative imports MUST use `.js` extension. Example: `import { InstallOptions } from '../types.js'` — even though the file is `types.ts`.

**Common pattern for installer files:**
- Import `InstallOptions` from `'../types.js'`
- The main exported function accepts `(opts: InstallOptions): Promise<void>` or `(name: string, opts: InstallOptions): Promise<void>` — read the actual signature from the JS file
- Type all local variables (string, boolean, etc.)
- For `catch (err)` blocks: since `strict: true` enables `useUnknownInCatchVariables`, type the error properly:
  - If using `err.message`: add `if (err instanceof Error) { console.error(err.message); } else { console.error(String(err)); }`
  - Or cast: `(err as Error).message` — acceptable for catch blocks where an Error is always expected
- Keep all existing logic exactly the same — this is a type-annotation-only migration

After creating both .ts files, delete agent.js and command.js.

Run `npx tsc --noEmit` to verify these two files compile. Fix any errors.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | grep -E "src/installers/(agent|command)" | grep -v "^$" || echo "agent/command: no tsc errors"</automated>
    <manual>Confirm src/installers/agent.js and command.js are deleted. Confirm agent.ts and command.ts exist.</manual>
  </verify>
  <done>src/installers/agent.ts and command.ts exist with TypeScript types. Old .js files deleted. Zero tsc errors for these two files.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate hook.ts and skill.ts</name>
  <files>src/installers/hook.ts, src/installers/skill.ts</files>
  <action>
Read `src/installers/hook.js` and `src/installers/skill.js` first to understand the current implementation.

**hook.ts — write-file-atomic CJS interop typing:**

The existing try/catch import pattern for write-file-atomic must be preserved exactly. Only add type annotations. Use this pattern:

```typescript
import type { default as WriteFileAtomic } from 'write-file-atomic';

let writeFileAtomic: typeof WriteFileAtomic;
try {
  const mod = await import('write-file-atomic');
  writeFileAtomic = mod.default;
} catch {
  const { createRequire } = await import('node:module');
  const require = createRequire(import.meta.url);
  writeFileAtomic = require('write-file-atomic');
}
```

If `@types/write-file-atomic` types the default export differently, adapt the type annotation accordingly — the key is that `writeFileAtomic` gets typed so its call signature is known. Use explicit `any` with `// TODO: type this properly` if the import type is genuinely hard to express.

Import `InstallOptions` from `'../types.js'`. Do NOT change the write-file-atomic logic, only add types.

**skill.ts — GitHub Contents API response typing:**

Import `GitHubContentsItem` from `'../types.js'`. The `res.json()` call returns the GitHub Contents API response — type it as `GitHubContentsItem[]` or `GitHubContentsItem` depending on the call. Read the existing code to determine which.

```typescript
const items = await res.json() as GitHubContentsItem[];
```

Import `InstallOptions` from `'../types.js'` for the opts parameter.

After creating both .ts files, delete hook.js and skill.js.

Run `npx tsc --noEmit` to verify. If ESLint reports `@typescript-eslint/no-explicit-any` on the interop variables, add `// eslint-disable-next-line @typescript-eslint/no-explicit-any` on the line above (as a last resort) — but first try to type properly using `import type`.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | grep -E "src/installers/(hook|skill)" | grep -v "^$" || echo "hook/skill: no tsc errors"</automated>
    <manual>Confirm src/installers/hook.js and skill.js are deleted. Confirm hook.ts and skill.ts exist. Confirm write-file-atomic try/catch logic is unchanged in hook.ts.</manual>
  </verify>
  <done>src/installers/hook.ts and skill.ts exist with TypeScript types. write-file-atomic CJS interop preserved and typed. GitHubContentsItem used for API responses. Old .js files deleted. Zero tsc errors for these files.</done>
</task>

</tasks>

<verification>
Run: `npx tsc --noEmit 2>&1 | grep "src/installers"` — should show no errors for installer files
Run: `ls src/installers/` — should show agent.ts, command.ts, hook.ts, skill.ts (no .js files)
</verification>

<success_criteria>
- All four installer .ts files exist with proper TypeScript types
- Old .js installer files deleted
- InstallOptions imported from ../types.js in all four files
- write-file-atomic CJS interop preserved and typed in hook.ts
- GitHubContentsItem used in skill.ts for GitHub API responses
- Zero tsc errors for all installer files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-typescript-migration/02.1-03-SUMMARY.md`
</output>
