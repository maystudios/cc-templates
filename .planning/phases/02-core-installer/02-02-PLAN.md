---
phase: 02-core-installer
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/installers/agent.js
  - src/installers/command.js
autonomous: true
requirements:
  - INST-02
  - INST-03
  - SAFE-01
  - SAFE-02
  - INST-05
  - INST-06

must_haves:
  truths:
    - "User runs npx cc-templates --agent <name> and the .md file appears at .claude/agents/<name>.md"
    - "User runs npx cc-templates --command <name> and the .md file appears at .claude/commands/<name>.md"
    - "If target file already exists and --force is not passed, install is aborted with one-liner warning"
    - "If target file already exists and --force is passed, file is overwritten with a warning listing the replaced file"
    - "If the component name is not in the catalog, error message lists all available components of that type"
  artifacts:
    - path: "src/installers/agent.js"
      provides: "Agent .md file installer"
      exports: ["installAgent"]
    - path: "src/installers/command.js"
      provides: "Command .md file installer"
      exports: ["installCommand"]
  key_links:
    - from: "src/installers/agent.js"
      to: "raw.githubusercontent.com"
      via: "buildRawUrl from fetch.js"
      pattern: "buildRawUrl"
    - from: "src/installers/agent.js"
      to: "src/catalog.js"
      via: "validateName before fetch"
      pattern: "validateName"
    - from: "src/installers/command.js"
      to: "raw.githubusercontent.com"
      via: "buildRawUrl from fetch.js"
      pattern: "buildRawUrl"
---

<objective>
Implement the agent and command installers — both follow the same single-file download pattern: validate name against catalog, check for conflicts, fetch the .md file from raw.githubusercontent.com, write to the correct target path.

Purpose: INST-02 (--agent) and INST-03 (--command) are the simplest install paths. Getting them right establishes the single-file pattern that is reused across installer types.
Output: src/installers/agent.js, src/installers/command.js
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-installer/02-01-SUMMARY.md
@src/fetch.js
@src/output.js
@src/catalog.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/installers/agent.js — single .md file installer for agents</name>
  <files>src/installers/agent.js</files>
  <action>
Create `src/installers/` directory and `src/installers/agent.js`. This module downloads a single .md file from raw.githubusercontent.com to `.claude/agents/<name>.md` (or `~/.claude/agents/<name>.md` when opts.global is true).

Full implementation:

```javascript
// src/installers/agent.js
import { existsSync, mkdirSync, writeFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { homedir } from 'node:os';
import { buildRawUrl } from '../fetch.js';
import { output } from '../output.js';
import { validateName } from '../catalog.js';

/**
 * Install an agent component (.md file) to .claude/agents/<name>.md
 * @param {string} name - Agent name (validated against catalog before calling)
 * @param {object} opts - CLI options: { force, global, verbose }
 */
export async function installAgent(name, opts = {}) {
  // SAFE-01: validate before fetching (catalog.js throws with inline list on failure)
  validateName('agent', name);

  // INST-05: resolve base dir
  const baseDir = opts.global ? homedir() : process.cwd();
  const targetPath = join(baseDir, '.claude', 'agents', `${name}.md`);

  // SAFE-02: conflict check
  if (existsSync(targetPath)) {
    if (!opts.force) {
      output.warn(`${name} already installed. Use --force to overwrite.`);
      return { success: false, reason: 'exists' };
    }
    // INST-06: --force warns before overwriting
    output.warn(`Overwriting existing: ${targetPath}`);
  }

  // Fetch from raw.githubusercontent.com
  const url = buildRawUrl('agents', `${name}.md`);
  if (opts.verbose) output.verbose(`  fetching ${url}`);

  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Failed to fetch agent "${name}" (HTTP ${res.status}): ${url}`);
  }
  const content = await res.text();

  // Write file (create parent dirs if needed — INST-05 / --global may require dir creation)
  mkdirSync(dirname(targetPath), { recursive: true });
  writeFileSync(targetPath, content, 'utf8');

  if (opts.verbose) output.verbose(`  wrote ${targetPath}`);

  // One-line success summary (per CONTEXT.md output decisions)
  const displayPath = opts.global
    ? `~/.claude/agents/${name}.md`
    : `.claude/agents/${name}.md`;
  output.success(`Installed ${name} agent to ${displayPath}`);
  output.hint(`Use this agent in Claude Code with @${name}`);

  return { success: true };
}
```

Key constraints from CONTEXT.md (locked decisions):
- Success message format: "Installed <name> agent to .claude/agents/<name>.md"
- Conflict warning format: "<name> already installed. Use --force to overwrite."
- --force warns BEFORE overwriting (lists which file will be replaced)
- Always validate against catalog FIRST (before any network call)
- opts.verbose gates verbose output — always call output.verbose() with guard inside this module; the orchestrator (install.js in Plan 05) may also gate on opts.verbose if needed
  </action>
  <verify>
    <automated>node --input-type=module &lt;&lt;&lt; "import { installAgent } from './src/installers/agent.js'; console.log('installAgent import OK'); try { await installAgent('nonexistent-xyz', {}); } catch(e) { if (e.message.includes('Available agents')) { console.log('SAFE-01 OK'); } else { throw e; } }"</automated>
    <manual>Module imports without error; SAFE-01 error message includes "Available agents:" when unknown name is passed</manual>
  </verify>
  <done>src/installers/agent.js created; exports installAgent; SAFE-01 validation fires before fetch; SAFE-02 conflict check fires before write; success/warn messages match CONTEXT.md format.</done>
</task>

<task type="auto">
  <name>Task 2: Create src/installers/command.js — single .md file installer for commands</name>
  <files>src/installers/command.js</files>
  <action>
Create `src/installers/command.js` — identical pattern to agent.js but targets `.claude/commands/<name>.md` and uses `validateName('command', name)` and `buildRawUrl('commands', ...)`.

Full implementation:

```javascript
// src/installers/command.js
import { existsSync, mkdirSync, writeFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { homedir } from 'node:os';
import { buildRawUrl } from '../fetch.js';
import { output } from '../output.js';
import { validateName } from '../catalog.js';

/**
 * Install a command component (.md file) to .claude/commands/<name>.md
 * @param {string} name - Command name
 * @param {object} opts - CLI options: { force, global, verbose }
 */
export async function installCommand(name, opts = {}) {
  // SAFE-01: validate before fetching
  validateName('command', name);

  // INST-05: resolve base dir
  const baseDir = opts.global ? homedir() : process.cwd();
  const targetPath = join(baseDir, '.claude', 'commands', `${name}.md`);

  // SAFE-02: conflict check
  if (existsSync(targetPath)) {
    if (!opts.force) {
      output.warn(`${name} already installed. Use --force to overwrite.`);
      return { success: false, reason: 'exists' };
    }
    // INST-06: --force warns before overwriting
    output.warn(`Overwriting existing: ${targetPath}`);
  }

  // Fetch from raw.githubusercontent.com
  const url = buildRawUrl('commands', `${name}.md`);
  if (opts.verbose) output.verbose(`  fetching ${url}`);

  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Failed to fetch command "${name}" (HTTP ${res.status}): ${url}`);
  }
  const content = await res.text();

  // Write file (create parent dirs if needed)
  mkdirSync(dirname(targetPath), { recursive: true });
  writeFileSync(targetPath, content, 'utf8');

  if (opts.verbose) output.verbose(`  wrote ${targetPath}`);

  const displayPath = opts.global
    ? `~/.claude/commands/${name}.md`
    : `.claude/commands/${name}.md`;
  output.success(`Installed ${name} command to ${displayPath}`);
  output.hint(`Use this command in Claude Code with /${name}`);

  return { success: true };
}
```

Do NOT add HTTP retry logic, timeout handling, or progress bars — these are not in the approved stack for Phase 2. Keep the implementation minimal: validate, check, fetch, write, report.
  </action>
  <verify>
    <automated>node --input-type=module &lt;&lt;&lt; "import { installCommand } from './src/installers/command.js'; console.log('installCommand import OK'); try { await installCommand('nonexistent-xyz', {}); } catch(e) { if (e.message.includes('Available commands')) { console.log('SAFE-01 OK'); } else { throw e; } }"</automated>
    <manual>Module imports without error; SAFE-01 error message includes "Available commands:" when unknown name is passed</manual>
  </verify>
  <done>src/installers/command.js created; exports installCommand; SAFE-01 validation fires before fetch; SAFE-02 conflict check fires before write; success message says "Installed <name> command to .claude/commands/<name>.md".</done>
</task>

</tasks>

<verification>
Both installers import cleanly and export the correct function:
```bash
node --input-type=module <<< "
import { installAgent } from './src/installers/agent.js';
import { installCommand } from './src/installers/command.js';
console.log('agent:', typeof installAgent);
console.log('command:', typeof installCommand);
"
```
Expected: "agent: function" and "command: function", no import errors.

SAFE-01 fires for unknown names (both types):
```bash
node --input-type=module <<< "
import { installAgent } from './src/installers/agent.js';
try { await installAgent('does-not-exist', {}); } catch(e) { console.log('agent SAFE-01:', e.message.slice(0, 60)); }
import { installCommand } from './src/installers/command.js';
try { await installCommand('does-not-exist', {}); } catch(e) { console.log('command SAFE-01:', e.message.slice(0, 60)); }
"
```
</verification>

<success_criteria>
- src/installers/agent.js: exports installAgent; uses validateName('agent', ...) before fetch; writes to .claude/agents/; --force overwrites with warning; --global writes to ~/.claude/agents/
- src/installers/command.js: exports installCommand; uses validateName('command', ...) before fetch; writes to .claude/commands/; same --force and --global behavior
- Both modules: import from '../fetch.js', '../output.js', '../catalog.js' without errors
- SAFE-01: unknown name → Error with "Available agents:/commands:" inline list
- SAFE-02: existing file + no --force → warn + return { success: false, reason: 'exists' }
- INST-06: existing file + --force → warn with file path, then overwrite
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-installer/02-02-SUMMARY.md`
</output>
