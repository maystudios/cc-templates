---
phase: 02-core-installer
plan: "04"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/installers/hook.js
autonomous: true
requirements:
  - INST-04
  - SAFE-06
  - SAFE-07
  - SAFE-01
  - SAFE-02
  - INST-05
  - INST-06

must_haves:
  truths:
    - "User runs npx cc-templates --hook <name> and the hook is appended to the correct event array in settings.json"
    - "Existing keys in settings.json are preserved — only the new hook entries are added"
    - "If settings.json does not exist, it is created with only the installed hook structure"
    - "If settings.json exists but contains invalid JSON, install is aborted with a clear error and the file is not touched"
    - "On Windows, python3 in hook command strings is replaced with python before writing"
    - "settings.json write is atomic — a process crash mid-write cannot corrupt the file"
  artifacts:
    - path: "src/installers/hook.js"
      provides: "Hook JSON installer with array-append deep-merge and atomic write"
      exports: ["installHook"]
  key_links:
    - from: "src/installers/hook.js"
      to: "settings.json"
      via: "write-file-atomic for atomic write"
      pattern: "writeFileAtomic"
    - from: "src/installers/hook.js"
      to: "src/fetch.js"
      via: "buildRawUrl('hooks', name + '.json')"
      pattern: "buildRawUrl"
    - from: "src/installers/hook.js"
      to: "src/catalog.js"
      via: "validateName('hook', name) before fetch"
      pattern: "validateName"
---

<objective>
Implement the hook installer — the most complex of the four install paths. Hooks require fetching a JSON descriptor, applying Windows python3 replacement, deep-merging hook entries into the existing settings.json event arrays (append, never replace), and writing atomically.

Purpose: INST-04 with SAFE-06 and SAFE-07 are the highest-risk operations in Phase 2 — a bad settings.json write can break Claude Code for the user. Atomic write and proper array-append merge are the critical safety guarantees.
Output: src/installers/hook.js
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-installer/02-01-SUMMARY.md
@src/fetch.js
@src/output.js
@src/catalog.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/installers/hook.js — JSON deep-merge installer with atomic write</name>
  <files>src/installers/hook.js</files>
  <action>
Create `src/installers/hook.js`. This module:
1. Validates the hook name against the catalog (SAFE-01)
2. Fetches the hook JSON descriptor from raw.githubusercontent.com
3. Applies Windows python3→python replacement (SAFE-07)
4. Reads existing settings.json (if present), validates it is parseable JSON (SAFE-06 malformed abort)
5. Deep-merges hook entries: appends to each event array, never replaces (SAFE-06 array-append)
6. Writes atomically via write-file-atomic (SAFE-06 atomic write)

**Critical merge rule (from CONTEXT.md locked decisions and RESEARCH.md):**
- `merged.hooks[event] = [...(existing.hooks[event] ?? []), ...newMatchers]`
- NEVER: `merged.hooks[event] = newMatchers` — this silently deletes user's existing hooks

**write-file-atomic import:** Use `import writeFileAtomic from 'write-file-atomic'` (CJS default import from ESM, works in Node 20+). If this fails at runtime with ERR_PACKAGE_IMPORT_NOT_DEFINED, apply the createRequire fallback (identical to js-yaml pattern in scripts/build-catalog.js).

**Hook JSON format fetched from GitHub:**
```json
{
  "hooks": {
    "PostToolUse": [{
      "matcher": "Edit|Write",
      "hooks": [{ "type": "command", "command": "python3 .claude/hooks/format.py" }]
    }]
  }
}
```

**Target settings.json format (official Anthropic schema, verified February 2026):**
```json
{
  "hooks": {
    "PreToolUse": [{ "matcher": "Bash", "hooks": [{ "type": "command", "command": "..." }] }],
    "PostToolUse": [{ "matcher": "Edit|Write", "hooks": [{ "type": "command", "command": "..." }] }]
  }
}
```

**Full implementation:**

```javascript
// src/installers/hook.js
import { existsSync, readFileSync, mkdirSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { homedir } from 'node:os';
import writeFileAtomic from 'write-file-atomic';
import { buildRawUrl } from '../fetch.js';
import { output } from '../output.js';
import { validateName } from '../catalog.js';

/**
 * Install a hook component by deep-merging its JSON into settings.json.
 * @param {string} name - Hook name
 * @param {object} opts - CLI options: { force, global, verbose }
 */
export async function installHook(name, opts = {}) {
  // SAFE-01: validate before any network call
  validateName('hook', name);

  // INST-05: resolve settings.json path
  const baseDir = opts.global ? homedir() : process.cwd();
  const settingsPath = join(baseDir, '.claude', 'settings.json');

  // Fetch hook JSON from GitHub
  const url = buildRawUrl('hooks', `${name}.json`);
  if (opts.verbose) output.verbose(`  fetching ${url}`);

  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Failed to fetch hook "${name}" (HTTP ${res.status}): ${url}`);
  }

  let hookData = await res.json();

  // SAFE-07: Windows python3 → python replacement
  // Applied to the whole JSON string (safe because component authors don't embed "python3" in path names)
  if (process.platform === 'win32') {
    hookData = JSON.parse(JSON.stringify(hookData).replace(/\bpython3\b/g, 'python'));
    if (opts.verbose) output.verbose('  applied python3→python replacement (Windows)');
  }

  // SAFE-06: Read existing settings.json
  let existing = {};
  if (existsSync(settingsPath)) {
    const raw = readFileSync(settingsPath, 'utf8');
    try {
      existing = JSON.parse(raw);
    } catch {
      // Malformed JSON — abort, do not touch file (SAFE-06 locked decision)
      throw new Error(
        `settings.json at ${settingsPath} contains invalid JSON. ` +
        `Fix it manually before installing hooks.`
      );
    }
  }

  // SAFE-06: Array-append merge — never replace existing hook entries
  const merged = { ...existing };
  merged.hooks = { ...(existing.hooks ?? {}) };
  const addedKeys = [];

  for (const [event, matchers] of Object.entries(hookData.hooks ?? {})) {
    if (!Array.isArray(merged.hooks[event])) {
      merged.hooks[event] = [];
    }
    // CRITICAL: spread existing array, then append new matchers
    merged.hooks[event] = [...merged.hooks[event], ...matchers];
    addedKeys.push(event);
  }

  // Ensure parent directory exists (--global may need ~/.claude/ creation)
  mkdirSync(dirname(settingsPath), { recursive: true });

  // SAFE-06: Atomic write — write to temp file, then rename (no partial-write corruption)
  await writeFileAtomic(settingsPath, JSON.stringify(merged, null, 2) + '\n');

  const keyList = addedKeys.join(', ');
  output.success(`Added ${keyList} hook to settings.json`);
  if (opts.verbose) {
    for (const key of addedKeys) {
      output.verbose(`  ${key}: appended ${hookData.hooks[key].length} matcher group(s)`);
    }
  }

  return { success: true };
}
```

**Anti-patterns to prevent (from RESEARCH.md pitfalls):**
- NEVER use `fs.writeFileSync` for settings.json — always use `writeFileAtomic`
- NEVER assign `merged.hooks[event] = newMatchers` — always spread existing + concat new
- NEVER silently swallow the JSON.parse error — always throw with "fix manually" message
- The python3 replacement uses `\bpython3\b` word boundary (safer than bare `python3`) — this is at Claude's discretion per CONTEXT.md
  </action>
  <verify>
    <automated>node --input-type=module &lt;&lt;&lt; "import { installHook } from './src/installers/hook.js'; console.log('installHook import OK', typeof installHook); try { await installHook('nonexistent-xyz', {}); } catch(e) { if (e.message.includes('Available hooks')) { console.log('SAFE-01 OK'); } else { throw e; } }"</automated>
    <manual>Module imports without error; SAFE-01 fires for unknown hook names; write-file-atomic import resolves</manual>
  </verify>
  <done>src/installers/hook.js created; exports installHook; write-file-atomic imported as default; SAFE-01 validates before fetch; SAFE-06 array-append merge implemented (spread existing + concat new); SAFE-06 malformed JSON abort implemented; SAFE-06 atomic write via writeFileAtomic; SAFE-07 python3 replacement applied on win32 platform.</done>
</task>

<task type="auto">
  <name>Task 2: Unit-test hook merge logic with a mock settings.json</name>
  <files></files>
  <action>
Run an in-process test of the hook merge logic without live GitHub calls. This verifies the most critical correctness properties:
1. Existing hooks survive the merge (array-append, not replace)
2. New hooks appear after existing ones
3. Malformed JSON aborts without touching the file
4. Missing settings.json creates it from scratch

Write a self-contained test script (not a file to keep, just execute and discard):

```bash
node --input-type=module <<'TESTEOF'
import { writeFileSync, readFileSync, existsSync, mkdirSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';

// Create isolated test dir
const testDir = join(tmpdir(), 'cc-templates-hook-test-' + Date.now());
mkdirSync(join(testDir, '.claude'), { recursive: true });

// --- Test 1: settings.json does not exist → creates it ---
// (We can't call installHook directly without live GitHub, so test the merge logic inline)

import writeFileAtomic from 'write-file-atomic';

async function testMerge(existingContent, hookData, expectKeys) {
  const settingsPath = join(testDir, '.claude', 'settings.json');

  if (existingContent !== null) {
    writeFileSync(settingsPath, existingContent, 'utf8');
  } else if (existsSync(settingsPath)) {
    rmSync(settingsPath);
  }

  let existing = {};
  if (existsSync(settingsPath)) {
    existing = JSON.parse(readFileSync(settingsPath, 'utf8'));
  }

  const merged = { ...existing };
  merged.hooks = { ...(existing.hooks ?? {}) };

  for (const [event, matchers] of Object.entries(hookData.hooks ?? {})) {
    if (!Array.isArray(merged.hooks[event])) merged.hooks[event] = [];
    merged.hooks[event] = [...merged.hooks[event], ...matchers];
  }

  await writeFileAtomic(settingsPath, JSON.stringify(merged, null, 2) + '\n');
  const result = JSON.parse(readFileSync(settingsPath, 'utf8'));

  for (const key of expectKeys) {
    if (!result.hooks[key]) throw new Error(`Missing hook key: ${key}`);
  }
  return result;
}

// Test 1: empty file → creates with new hook
const t1 = await testMerge(null, { hooks: { PostToolUse: [{ matcher: 'Edit', hooks: [] }] } }, ['PostToolUse']);
console.log('Test 1 PASS: created settings.json from scratch');

// Test 2: existing hooks survive (array-append)
const existingSettings = JSON.stringify({
  hooks: { PreToolUse: [{ matcher: 'Bash', hooks: [{ type: 'command', command: 'guard.sh' }] }] }
});
const t2 = await testMerge(existingSettings, { hooks: { PostToolUse: [{ matcher: 'Edit', hooks: [] }] } }, ['PreToolUse', 'PostToolUse']);
if (t2.hooks.PreToolUse.length !== 1) throw new Error('PreToolUse was clobbered!');
if (t2.hooks.PostToolUse.length !== 1) throw new Error('PostToolUse missing');
console.log('Test 2 PASS: existing hooks preserved, new hook added');

// Test 3: appends to same event (not replace)
const existingWithPost = JSON.stringify({
  hooks: { PostToolUse: [{ matcher: 'Read', hooks: [{ type: 'command', command: 'old.sh' }] }] }
});
const t3 = await testMerge(existingWithPost, { hooks: { PostToolUse: [{ matcher: 'Edit', hooks: [] }] } }, ['PostToolUse']);
if (t3.hooks.PostToolUse.length !== 2) throw new Error(`Expected 2 PostToolUse entries, got ${t3.hooks.PostToolUse.length}`);
console.log('Test 3 PASS: same event array has both old and new matchers');

// Cleanup
rmSync(testDir, { recursive: true });
console.log('\nAll hook merge tests PASSED');
TESTEOF
```

If write-file-atomic import fails (Node 20.0-20.16 edge case), apply the createRequire fallback and re-run.
  </action>
  <verify>
    <automated>node --input-type=module --eval "import writeFileAtomic from 'write-file-atomic'; console.log('write-file-atomic OK:', typeof writeFileAtomic);"</automated>
    <manual>All three merge tests print "PASS"; "All hook merge tests PASSED" printed at end</manual>
  </verify>
  <done>All three hook merge tests pass: (1) creates settings.json from scratch, (2) existing hooks preserved after merge, (3) same-event array has both old and new entries. write-file-atomic default import works.</done>
</task>

</tasks>

<verification>
Import check:
```bash
node --input-type=module <<< "import { installHook } from './src/installers/hook.js'; console.log(typeof installHook);"
```
Expected: "function"

SAFE-01 for unknown hook:
```bash
node --input-type=module <<< "
import { installHook } from './src/installers/hook.js';
try { await installHook('nonexistent', {}); } catch(e) { console.log(e.message.slice(0, 80)); }
"
```
Expected: message contains '"nonexistent" is not a known hook. Available hooks:'

write-file-atomic atomic write working:
```bash
node --input-type=module <<< "import writeFileAtomic from 'write-file-atomic'; console.log(typeof writeFileAtomic);"
```
Expected: "function"
</verification>

<success_criteria>
- src/installers/hook.js: exports installHook; uses write-file-atomic for all settings.json writes
- SAFE-01: unknown hook name → Error with inline "Available hooks:" list
- SAFE-06 array-append: new hook entries appended to existing event arrays, not replacing them
- SAFE-06 malformed JSON: existing settings.json with bad JSON → abort with clear message, file untouched
- SAFE-06 atomic: writeFileAtomic used (not fs.writeFileSync)
- SAFE-07: on win32 platform, python3 replaced with python in hook command strings before merge
- INST-05: opts.global=true → settingsPath uses homedir() base
- INST-06: not applicable to hooks (no directory conflict check — hooks always merge, never abort for "already installed")
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-installer/02-04-SUMMARY.md`
</output>
