---
phase: 02-core-installer
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/fetch.js
  - src/output.js
  - src/catalog.js
  - package.json
autonomous: true
requirements:
  - INST-07
  - SAFE-01
  - INST-05

must_haves:
  truths:
    - "All installer modules can import fetch helpers, output helpers, and catalog validation without errors"
    - "Catalog validation throws with inline list of available names when an unknown component name is passed"
    - "GitHub URLs are constructed using CC_TEMPLATES_REPO env var when set, falling back to the default repo"
    - "Chalk output auto-detects TTY — colored in terminal, plain text in CI/piped contexts"
  artifacts:
    - path: "src/fetch.js"
      provides: "GitHub URL builder with CC_TEMPLATES_REPO override"
      exports: ["buildRawUrl", "buildContentsApiUrl"]
    - path: "src/output.js"
      provides: "Chalk-based output helpers with TTY auto-detection"
      exports: ["output"]
    - path: "src/catalog.js"
      provides: "Bundled components.json reader and name validator"
      exports: ["validateName", "getAvailable"]
    - path: "package.json"
      provides: "write-file-atomic dependency added"
      contains: "write-file-atomic"
  key_links:
    - from: "src/catalog.js"
      to: "components.json"
      via: "readFileSync at module load time"
      pattern: "components\\.json"
    - from: "src/fetch.js"
      to: "process.env.CC_TEMPLATES_REPO"
      via: "getRepo() function"
      pattern: "CC_TEMPLATES_REPO"
---

<objective>
Create the three shared foundation modules all installers depend on: URL builder (fetch.js), output helpers (output.js), and catalog validator (catalog.js). Also install the write-file-atomic dependency needed by the hook installer.

Purpose: All four component-type installers (Plans 02-04) import from these modules. Building foundations in Wave 1 lets installer plans run in parallel in Wave 2.
Output: src/fetch.js, src/output.js, src/catalog.js, updated package.json with write-file-atomic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-scaffold/01-01-SUMMARY.md
@src/cli.js
@components.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/fetch.js — GitHub URL builder with CC_TEMPLATES_REPO override</name>
  <files>src/fetch.js</files>
  <action>
Create `src/fetch.js` as an ES module. This is the single source of truth for all GitHub URLs — no installer may hardcode a URL.

Implementation:

```javascript
// src/fetch.js
const DEFAULT_REPO = 'anthropics-community/cc-templates'; // actual GitHub org/repo
const BRANCH = 'main';

function getRepo() {
  return process.env.CC_TEMPLATES_REPO ?? DEFAULT_REPO;
}

/**
 * Build raw.githubusercontent.com URL for a single file component (agents, commands, hooks).
 * @param {string} type  - Component type folder name: 'agents', 'commands', 'hooks'
 * @param {string} filename - e.g. 'my-agent.md' or 'my-hook.json'
 */
export function buildRawUrl(type, filename) {
  const repo = getRepo();
  return `https://raw.githubusercontent.com/${repo}/${BRANCH}/components/${type}/${filename}`;
}

/**
 * Build GitHub Contents API URL for a skill directory.
 * @param {string} type - 'skills'
 * @param {string} name - skill directory name, e.g. 'video-download'
 */
export function buildContentsApiUrl(type, name) {
  const repo = getRepo();
  return `https://api.github.com/repos/${repo}/contents/components/${type}/${name}`;
}
```

Note: Use the actual GitHub repo owner/org that matches where this package's source lives. If the real org name is not known, use `your-org/cc-templates` as a placeholder — the executor MUST check package.json repository field or existing README for the actual repo URL and use that instead of a placeholder.
  </action>
  <verify>
    <automated>node --input-type=module &lt;&lt;&lt; "import { buildRawUrl, buildContentsApiUrl } from './src/fetch.js'; const u1 = buildRawUrl('agents', 'foo.md'); const u2 = buildContentsApiUrl('skills', 'video-download'); if (!u1.includes('raw.githubusercontent.com')) throw new Error('bad raw URL'); if (!u2.includes('api.github.com')) throw new Error('bad API URL'); console.log('fetch.js OK:', u1);"</automated>
    <manual>Run with CC_TEMPLATES_REPO=myorg/myrepo and verify the URL contains myorg/myrepo</manual>
  </verify>
  <done>src/fetch.js exports buildRawUrl and buildContentsApiUrl; URLs include the correct GitHub domains; CC_TEMPLATES_REPO env var overrides the default repo in both functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create src/output.js — chalk-based output helpers with TTY auto-detection</name>
  <files>src/output.js</files>
  <action>
Create `src/output.js` as an ES module. Uses chalk (already installed from Phase 1 — chalk@5.4.1). Chalk 5 auto-detects TTY via supports-color — no manual isTTY check needed.

Provide an `output` object with these methods:
- `output.success(msg)` — green checkmark prefix
- `output.warn(msg)` — yellow warning prefix
- `output.error(msg)` — red error prefix
- `output.hint(msg)` — dim/gray prefix for usage hints
- `output.verbose(msg)` — dim prefix for verbose-mode details (always called by installers; callers gate on opts.verbose)
- `output.info(msg)` — no color prefix, plain info

Color choices are at Claude's discretion per CONTEXT.md. Reasonable choices:
- success: chalk.green('✓')
- warn: chalk.yellow('⚠')
- error: chalk.red('✗')
- hint: chalk.dim('→')
- verbose: chalk.dim(' ')

Example implementation:

```javascript
import chalk from 'chalk';

export const output = {
  success: (msg) => console.log(`${chalk.green('✓')} ${msg}`),
  warn:    (msg) => console.warn(`${chalk.yellow('⚠')} ${msg}`),
  error:   (msg) => console.error(`${chalk.red('✗')} ${msg}`),
  hint:    (msg) => console.log(chalk.dim(`→ ${msg}`)),
  verbose: (msg) => console.log(chalk.dim(msg)),
  info:    (msg) => console.log(msg),
};
```

Note: Do NOT manually check process.stdout.isTTY — chalk 5 handles this. Do NOT use ora or spinners (not in the approved stack).
  </action>
  <verify>
    <automated>node --input-type=module &lt;&lt;&lt; "import { output } from './src/output.js'; output.success('ok'); output.warn('careful'); output.error('bad'); output.hint('try this'); output.verbose('detail'); console.log('output.js OK');"</automated>
  </verify>
  <done>src/output.js exports an output object with success, warn, error, hint, verbose, and info methods; all methods call console.log/warn/error; chalk import resolves without error.</done>
</task>

<task type="auto">
  <name>Task 3: Create src/catalog.js and install write-file-atomic</name>
  <files>src/catalog.js, package.json</files>
  <action>
**Step A — Install write-file-atomic:**

```bash
npm install write-file-atomic@^7
```

This adds write-file-atomic to package.json dependencies. It is a CJS package but importable from ESM via default import: `import writeFileAtomic from 'write-file-atomic'`. If that fails at runtime (Node 20.0-20.16 edge case), apply the createRequire fallback from build-catalog.js pattern established in Phase 1.

**Step B — Create src/catalog.js:**

Reads the bundled `components.json` at module load time (synchronous — file is always present in the npm package, COMP-05). Provides `validateName` which throws with an inline list of available names when the requested component is not found (SAFE-01).

```javascript
// src/catalog.js
import { readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const catalog = JSON.parse(
  readFileSync(join(__dirname, '../components.json'), 'utf8')
);

/**
 * Map CLI type name to components.json key.
 * CLI flag: skill, agent, command, hook, mcp
 * components.json key: skills, agents, commands, hooks, mcp
 */
function getCatalogKey(type) {
  if (type === 'mcp') return 'mcp';
  return `${type}s`; // skill -> skills, agent -> agents, command -> commands, hook -> hooks
}

/**
 * Get all available entries for a component type.
 * @param {string} type - 'skill' | 'agent' | 'command' | 'hook' | 'mcp'
 * @returns {Array} array of catalog entries
 */
export function getAvailable(type) {
  return catalog[getCatalogKey(type)] ?? [];
}

/**
 * Validate that a component name exists in the bundled catalog.
 * Throws with inline list of available names if not found (SAFE-01).
 * @param {string} type - 'skill' | 'agent' | 'command' | 'hook' | 'mcp'
 * @param {string} name - Component name to validate
 */
export function validateName(type, name) {
  const entries = getAvailable(type);
  const found = entries.find(e => e.name === name);
  if (!found) {
    const available = entries.map(e => e.name);
    const listStr = available.length > 0 ? available.join(', ') : '(none yet)';
    throw new Error(
      `"${name}" is not a known ${type}. Available ${type}s: ${listStr}`
    );
  }
  return found; // returns the catalog entry (has name, description, author)
}
```

Note: `components.json` uses keys `skills`, `hooks`, `commands`, `mcp` — no `agents` key currently exists (Phase 1 seeded only skills). The catalog.js must handle a missing key gracefully by returning `[]` from `getAvailable`. This is correct — INST-02 allows installing agents even though none are in the catalog yet (for agents, validate against the catalog if entries exist; if the key is missing, consider the name invalid but with message "(none yet)").
  </action>
  <verify>
    <automated>node --input-type=module &lt;&lt;&lt; "import { validateName, getAvailable } from './src/catalog.js'; const skills = getAvailable('skill'); if (!Array.isArray(skills)) throw new Error('getAvailable returned non-array'); console.log('skills:', skills.map(s => s.name)); try { validateName('skill', 'nonexistent-xyz'); throw new Error('should have thrown'); } catch(e) { if (!e.message.includes('Available skills')) throw e; console.log('validation error OK:', e.message.slice(0, 80)); } validateName('skill', 'video-download'); console.log('catalog.js OK');"</automated>
  </verify>
  <done>write-file-atomic appears in package.json dependencies; src/catalog.js exports validateName and getAvailable; validateName('skill', 'video-download') resolves without error; validateName('skill', 'nonexistent') throws with message containing "Available skills:".</done>
</task>

</tasks>

<verification>
All three modules load cleanly from ESM:
```bash
node --input-type=module <<< "
import { buildRawUrl } from './src/fetch.js';
import { output } from './src/output.js';
import { validateName, getAvailable } from './src/catalog.js';
output.success('All foundation modules loaded');
console.log('Available skills:', getAvailable('skill').map(s => s.name).join(', '));
"
```
Expected: no import errors, "Available skills: video-download, video-fetch-and-summarize, video-summarizer" printed.

write-file-atomic installed:
```bash
node --input-type=module <<< "import writeFileAtomic from 'write-file-atomic'; console.log(typeof writeFileAtomic);"
```
Expected: "function"
</verification>

<success_criteria>
- src/fetch.js: exports buildRawUrl, buildContentsApiUrl; CC_TEMPLATES_REPO env override works
- src/output.js: exports output object with 6 methods; no import errors; chalk renders in TTY
- src/catalog.js: exports validateName, getAvailable; validates 'video-download' as valid; throws for unknown names with inline list
- package.json: write-file-atomic in dependencies section
- node_modules/write-file-atomic exists after npm install
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-installer/02-01-SUMMARY.md`
</output>
