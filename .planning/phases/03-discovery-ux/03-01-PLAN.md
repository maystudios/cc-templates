---
phase: 03-discovery-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/menu.ts
autonomous: true
requirements:
  - DISC-01

must_haves:
  truths:
    - "Running `npx cc-templates` (no flags) launches a two-level interactive arrow-key menu"
    - "Level 1 shows four component types (Skills, Agents, Commands, Hooks) via @inquirer/select"
    - "Level 2 shows components for the chosen type via @inquirer/search with live type-to-filter"
    - "Pressing Escape on the level 2 list returns to level 1 (via '← Back' item)"
    - "Pressing Ctrl+C or Escape on level 1 exits cleanly with code 0 and no error message"
    - "Selecting a component immediately triggers install (no confirmation step)"
    - "Menu exits after a single install; user must run again for more"
  artifacts:
    - path: "src/menu.ts"
      provides: "Two-level interactive menu loop (DISC-01)"
      min_lines: 40
      exports: ["runMenu"]
    - path: "package.json"
      provides: "@inquirer/prompts production dependency"
      contains: "@inquirer/prompts"
  key_links:
    - from: "src/menu.ts"
      to: "@inquirer/prompts"
      via: "import { select, search, Separator, ExitPromptError } from '@inquirer/prompts'"
      pattern: "from '@inquirer/prompts'"
    - from: "src/menu.ts"
      to: "src/install.ts"
      via: "runInstall({ [type]: name })"
      pattern: "runInstall"
    - from: "src/menu.ts"
      to: "src/catalog.ts"
      via: "getAvailable(type) to populate search choices"
      pattern: "getAvailable"
---

<objective>
Install @inquirer/prompts and create src/menu.ts — the two-level interactive component picker.

Purpose: Enables users to discover and install components without knowing names in advance (DISC-01). The menu is the primary UX surface of Phase 3.
Output: src/menu.ts exporting runMenu(), @inquirer/prompts added to package.json dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/03-discovery-ux/03-CONTEXT.md
@.planning/phases/03-discovery-ux/03-RESEARCH.md
@src/catalog.ts
@src/install.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @inquirer/prompts dependency</name>
  <files>package.json, package-lock.json</files>
  <action>
    Run: `npm install @inquirer/prompts`

    This installs @inquirer/prompts ^8.3.0 as a production dependency. The package is ESM-native and Node 22 compatible — verified in research.

    After install, verify the package.json `dependencies` section now contains "@inquirer/prompts".

    Do NOT install the legacy `inquirer` package. Only `@inquirer/prompts` (the v8 modular rewrite).
  </action>
  <verify>
    <automated>node -e "import('@inquirer/prompts').then(m => { console.log('ok', typeof m.select, typeof m.search); }).catch(e => { console.error(e); process.exit(1); })"</automated>
    <manual>Check package.json has "@inquirer/prompts" in dependencies (not devDependencies)</manual>
  </verify>
  <done>"@inquirer/prompts" appears in package.json dependencies and the dynamic import resolves select and search as functions</done>
</task>

<task type="auto">
  <name>Task 2: Create src/menu.ts — two-level interactive menu</name>
  <files>src/menu.ts</files>
  <action>
    Create `src/menu.ts` implementing the two-level menu loop. This file is NEW — create it from scratch.

    **Imports:**
    ```typescript
    import { select, search, Separator } from '@inquirer/prompts';
    import { getAvailable } from './catalog.js';
    import { runInstall } from './install.js';
    import type { ComponentType, CatalogEntry } from './types.js';
    ```

    **COMPONENT_TYPES constant** (in display order):
    ```typescript
    const COMPONENT_TYPES: Array<{ label: string; type: ComponentType }> = [
      { label: 'Skills',   type: 'skill' },
      { label: 'Agents',   type: 'agent' },
      { label: 'Commands', type: 'command' },
      { label: 'Hooks',    type: 'hook' },
    ];
    ```

    **runMenu() function** — exported async function implementing the two-level loop:

    Outer loop: Use `select<ComponentType>` with message "What type of component do you want to install?" and choices built from COMPONENT_TYPES. No loop needed at this level — the Back functionality from level 2 returns here via `continue`.

    Use `while (true)` loop wrapping both prompts so Back from level 2 re-runs the outer select.

    Inner level: Call `getAvailable(chosenType)` to get entries. Use `search<string | '__back__'>` with:
    - message: `Pick a ${chosenType} to install`
    - source function that accepts `(input: string | void)`:
      - Guard: `const term = (input ?? '').toLowerCase();`
      - Filter entries where `!term || name.includes(term) || description.includes(term)` (both null-guarded)
      - Return: `Promise.resolve([{ name: '← Back', value: '__back__' }, new Separator(), ...filteredChoices])`
      - Each filtered choice: `{ name: entry.name ?? '', value: entry.name ?? '', description: entry.description ?? undefined }`
      - IMPORTANT: Always return the '← Back' item regardless of the current filter term — it must always be visible

    After search resolves:
    - If result === `'__back__'` → `continue` (re-runs outer while loop, shows type picker again)
    - Otherwise → call `await runInstall({ [chosenType]: chosenName } as InstallOptions)` and `break` (single install per session — locked decision)

    **Type for the cast:** Import `InstallOptions` from `./types.js` and cast: `{ [chosenType]: chosenName } as InstallOptions`.

    Do NOT catch ExitPromptError here — that is handled in src/cli.ts (locked: single catch point).
    Do NOT call process.exit() inside runMenu().
    Do NOT add a confirmation step — immediate install on Enter is a locked decision.
    Do NOT add search/filter at the type-selection level (level 1) — locked decision.
  </action>
  <verify>
    <automated>node --input-type=module --eval "import { runMenu } from './dist/menu.js'; console.log(typeof runMenu);" 2>/dev/null || (npm run build 2>&1 | tail -5 && node --input-type=module --eval "import { runMenu } from './dist/menu.js'; console.log(typeof runMenu);")</automated>
    <manual>After build: check dist/menu.js exists and typeof runMenu is 'function'</manual>
  </verify>
  <done>src/menu.ts compiles without TypeScript errors; dist/menu.js exists after `npm run build`; runMenu export resolves as a function</done>
</task>

</tasks>

<verification>
1. `npm install @inquirer/prompts` succeeded — package in dependencies
2. `npm run build` passes with no TypeScript errors on src/menu.ts
3. `node -e "import('./dist/menu.js').then(m => console.log(typeof m.runMenu))"` prints `function`
4. `@inquirer/prompts` imports resolve: `select`, `search`, `Separator` are all available
</verification>

<success_criteria>
- @inquirer/prompts is installed as a production dependency
- src/menu.ts exists and exports runMenu()
- TypeScript compiles src/menu.ts without errors
- The two-level loop structure is correct: while(true) > select for type > search for component > runInstall or continue
- '← Back' item is always present in search results regardless of filter input
- ExitPromptError is NOT caught inside menu.ts (that belongs in cli.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/03-discovery-ux/03-01-SUMMARY.md` with:
- What was installed/created
- Any TypeScript issues encountered and how they were resolved
- Exact @inquirer/prompts version installed (from package.json)
- Confirmation that runMenu compiles and exports correctly
</output>
